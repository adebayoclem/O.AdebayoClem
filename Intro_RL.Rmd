---
title: "Linking ECDS with sentinel data"
date: "Feb 2024"
output: 
  html_document:
    number_sections: yes
    toc: yes
    theme: cerulean 
pdf_document:
  toc: yes
---

------------------------------------------------------------------------

# Setup

## Import R libraries & set working directory

```{r packages message=FALSE}
# Import libraries
pacman::p_load(
  pacman,
  tidyverse,
  readxl,
  writexl,
  DBI,
  odbc,
  knitr,
  data.table,
  kableExtra,
  janitor
)
```

## Set your working directory

```{r wd, include=FALSE}
# Set working directory & list files
setwd("//filecol18/Project HIV&STI DataStore/STI Surveillance/GUMCAD/Analysis/Ubah/Info requests/NCSP/NCSP_JE/ct_testing")

```

------------------------------------------------------------------------

# Datasets

## Primary_file.csv

```{r load ECDS}
# Load in ECDS data
#ESTABLISH ODBC CONNECTION WITH DATA
Y006 <- odbc::dbConnect(odbc::odbc(),
                        .connection_string = "driver={SQL Server};server=SQLClusColLK19\\Lake19;
                             database=Y006_BBV_PID;
                             Encrypt=true;trusted_connection=true",
                        timeout = 60,
                        timezone = Sys.timezone(),
                        timezone_out = Sys.timezone())

ECDS <- DBI::dbGetQuery(conn = Y006 , statement = "SELECT TOP (1000) [PheKey]
      ,[TOKEN_PERSON_ID]
      ,[BIRTH_DATE]
      ,[NHS_NUMBER]
      ,[POSTCODE]
      ,[PROVIDER_CODE_DERIVED]
      ,[SITE]
      ,[ARRIVAL_MONTH]
      ,[ARRIVAL_DATE]
      ,[FYEAR]
      ,[InvestigationIdx]
      ,[INVESTIGATION_DATE]
      ,[INVESTIGATION_CODE_Description]
      ,[AGE_AT_ARRIVAL]
      ,[age_group]
      ,[agesex]
      ,[Sex]
      ,[ethnic_group]
      ,[LSOA_2011]
      ,[IMD2019_Deciles_LSOA11_withinUTLA21]
      ,[ETHNIC_CATEGORY]
      ,[ETHNIC_CATEGORY_Description]
      ,[STATED_GENDER]
      ,[INTERPRETER_LANGUAGE_Description]
      ,[INTERPRETER_LANGUAGE_VALID]
      ,[PREFERRED_SPOKEN_LANGUAGE_Description]
      ,[PREFERRED_SPOKEN_LANGUAGE_VALID]
      ,[ACCOMMODATION_STATUS_Description]
      ,[ACCOMMODATION_STATUS_VALID]
      ,[DRUG_ALCOHOL_CODE_1_Description]
      ,[IMD2019_Quintiles]
      ,[London_Provider_ICS]
      ,[Provider_derived]
      ,[included_sites]
      ,[Sentinel_sites]
      ,[London_sites]
      ,[outside_sites]
      ,[five_included_site]
      ,[live_HCV]
      ,[live_HBV]
      ,[live_HIV]
      ,[live_HCV_Date]
      ,[live_HBV_Date]
      ,[live_HIV_Date]
      ,[ECDS_bloods_any]
      ,[BBVtest]
      ,[HCV]
      ,[HBV]
      ,[HIV]
      ,[HCVdiff]
      ,[HBVdiff]
      ,[HIVdiff]
      ,[HCVresult]
      ,[HBVresult]
      ,[HCVAb]
      ,[HCVPCR]
      ,[HBVAg]
      ,[HBVVL]
      ,[HBsAg_positive_new]
      ,[rna_positive_new]
      ,[RNAtimingdiff]
      ,[RNAtiming]
      ,[LinkedtoRx]
      ,[RXtiming]
      ,[RX28days]
      ,[homelessflag]
      ,[testedinaprison]
      ,[testedindrugservice]
      ,[PWID_2]
  FROM [Y006_BBV_PID].[dbo].[12monthECDS_JE]") %>%
  clean_names()

```

```{r summary}
# Number of observations, missing values, %_complete, distinct values for each column
n_obs <- nrow(ECDS)
missing_values <- colSums(is.na(ECDS))
distinct_values <- sapply(ECDS, function(x) length(unique(x)))
complete_perc <- round((((n_obs-missing_values) / n_obs)*100),2)

# Create a summary data frame
ECDS_summary <- data.frame(
  n = n_obs,
  missing = missing_values,
  perc_complete = complete_perc,
  distinct = distinct_values
)


# print 
kable(head(ECDS, n=5), caption = 'ECDS: Top 5 rows') %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")


ECDS_summary %>%
  kbl(caption = 'Summary: ECDS') %>%
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Linking_file

```{r load sentinel}
SGSS <- DBI::dbGetQuery(conn = Y006 , statement = "SELECT TOP (1000) [SpecimenNumber]
,[SpecimenDate]
,[PtDOB]
,[PtName]
,[Surname]
,[Forename]
,[Sex]
,[PtNumber]
,[PtNHSNumber]
,[LocationName]
,[HCVtest]
,[HBVtest]
,[HIVtest]
,[HospitalName]
,[Ethnicity_Lab]
,[Laboratory]
,[HES_eth]
,[Age]
,[Age_group]
,[Postcode]
,[LSOA]
,[IMD]
,[RegisterGP]
,[DBSScore]
,[Died]
,[Dateofbirth]
,[Dateofbirth2]
,[UNIQUEID]
,[Evidenceofhomelessness]
,[Dupe_Sample]
,[DupdedID]
,[DUPID]
,[HCV_Antibody]
,[HCV_Antigen]
,[HCVPCR]
,[HBVSurfaceAntigen]
,[HBVSurfaceAntibody]
,[HBVVIRALLOAD]
,[HBCoreIgM]
,[HBVCoretotal]
,[HIV]
,[HIVVIRALLOAD]
,[ExcludeAb]
,[ExcludeAg]
,[ExcludePCR]
,[HCV_ALLFINALID]
,[HCVEED]
,[RxFINALID]
,[testedindrugservice]
,[testedinaprison]
,[homelessflag]
,[ExcludeHBVAg]
,[ExcludeHBVVL]
,[ExcludeHBcIgM]
,[ExcludeHBtotal]
,[HBV_ALLFINALID]
,[EEDHBV]
,[HCVRxCOB]
,[HCVRxRinf]
,[HCVRxEth]
,[HCVRxPWIDstatus]
,[HCVRisk]
,[CombinedEthnicity]
,[minsentineldate]
,[EthHESnew]
,[EthHESnew2]
,[AEtoken]
,[PreferredLanguageECDS]
,[DrugAlcohol1]
,[DrugAlcohol2]
,[DrugAlcohol3]
,[DrugAlcohol4]
,[ECDSETHNIC_CATEGORY_Description]
,[INTERPRETER_LANGUAGE_Description]
,[Accomodationstatus]
,[Overseascharging]
,[Trust]
,[Providercode]
,[Hospital]
,[PWID_2]
,[rna_positive_new]
,[RNAtimingdiff]
,[RNAtiming]
,[LinkedtoRx]
,[RXtiming]
,[RX28days]
,[HBsAg_positive_new]
FROM [Y006_BBV_PID].[dbo].[EmergencyDepartment_tests]") %>%
  clean_names()
```

```{r sent_summary}

# Number of observations, missing values, %_complete, distinct values for each column
n_obs <- nrow(SGSS)
missing_values <- colSums(is.na(SGSS))
distinct_values <- sapply(SGSS, function(x) length(unique(x)))
complete_perc <- round((((n_obs-missing_values) / n_obs)*100),2)

# Create a summary data frame
SGSS_summary <- data.frame(
  n = n_obs,
  missing = missing_values,
  perc_complete = complete_perc,
  distinct = distinct_values
)

# print 
kable(head(SGSS, n=5), caption = 'SGSS: Top 5 rows ') %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")


SGSS_summary %>%
  kbl(caption = 'Summary: SGSS') %>%
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Next steps

-   Undertake exploratory data analysis and review the summaries to identify variables common to both datasets that can be used for linkage.

```{r compare columns}
ECDS_cols <- as.data.frame(colnames(ECDS)) %>%
  mutate(source = "ECDS") %>%
  rename(colnames = `colnames(ECDS)`)

SGSS_cols <- as.data.frame(colnames(SGSS)) %>%
  mutate(source = "SGSS") %>%
  rename(colnames = `colnames(SGSS)`)

compared <- ECDS_cols %>%
  full_join(SGSS_cols, by = "colnames")
```

-   Looking at completeness for variable 'nhs' across both datasets, we observe that it is available for a small subset of records in the Linking file. This will facilitate 'Deterministic Linkage'.

-   Assumption for this exercise is that the NHS number is unique and correct.

-   We will link both datasets using available NHS numbers to create subset that contains 'comparison pairs'.

-   This subset can be used as a 'Gold-standard' from which m & u probabilities can be calculated.

## Naming conventions

-   Note that both datasets contain variables with the same naming convention, which will cause confusion when identifying these variables after linkage.

-   Therefore, one approach to overcome this, is to add a prefix to each variable:

    -   For variables in Primary file add P\_

    -   For variables in Linking file add L\_

### Rename variables: SGSS

```{r}
# Get the column names
column_names <- names(SGSS)
L_column_names <- data.frame(Original = column_names)
new_names <- c("L_id2", "L_nhs", "L_dob", "L_sex", "L_soundex", "L_year", "L_date1", "L_date2")
L_column_names$Updated <- new_names

L_column_names %>%
  kbl(caption = 'Renamed variables') %>%
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

# Update 
names(SGSS) <- new_names
```

### Rename variables: df_Primary

```{r}
# Get the column names
column_names <- names(df_primary)
P_column_names <- data.frame(Original = column_names)
new_names <- c("P_id1","P_nhs","P_dob", "P_sex", "P_soundex", "P_year")
P_column_names$Updated <- new_names

P_column_names %>%
  kbl(caption = 'Renamed variables') %>%
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

# Update 
names(df_primary) <- new_names
```

------------------------------------------------------------------------

# Deterministic linkage with NHS number

-   Perform a cross-join on the NHS number, where P_nhs == L_nhs.
-   Reorder columns & sort by ascending ids

```{r}
# Merge df_primary and df_linking based on the 'nhs' variable
merged_df <- merge(df_linking, df_primary, by.x = "L_nhs", by.y = "P_nhs")

# Specify order
desired_order <- c("P_id1", "L_id2", "L_nhs", "P_dob", "L_dob", "P_sex", "L_sex", "P_soundex", "L_soundex", "P_year", "L_year", "L_date1", "L_date2")

# Reorder the columns in 'merged_df'
merged_df <- merged_df %>% 
  select(all_of(desired_order))
rm(desired_order)

# Sort
sorted_indices <- order(merged_df$P_id1, merged_df$L_id2)
merged_df <- merged_df[sorted_indices, ]
rm(sorted_indices)

# No output
```

## Linkage summary

```{r}
# Function
count_info <- function(data_frame, nhs_column) {
  df_name <- deparse(substitute(data_frame))
  num_rows <- nrow(data_frame)
  num_columns <- ncol(data_frame)
  nhs_counts <- table(data_frame[[nhs_column]])
  
  result <- data.frame(
    DF = df_name,
    Num_Columns = num_columns,
    Num_Rows = num_rows,
    NHS_Column_Rows = sum(nhs_counts)
  )
  return(result)
}

# Apply function & Combine dfs
df_linking_info <- count_info(df_linking, "L_nhs")
df_primary_info <- count_info(df_primary, "P_nhs")
merged_df_info <- count_info(merged_df, "L_nhs")
summary_df <- rbind(df_linking_info, df_primary_info, merged_df_info)

kable(head(summary_df), caption = 'Summary') %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## View merged_df

```{r}
kable(head(merged_df, n=5), caption = 'Merged_df: Top 5 rows. (Note: P_nhs is automatically removed during process).') %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Summary merged_df

Obtain a summary for merged_df, focus on duplicates for P_id1 and L_id2

```{r}
# Function to count duplicate values in a column
count_duplicates <- function(x) {
  sum(duplicated(x) | duplicated(x, fromLast = TRUE))
}

# Count duplicates for each column
duplicate_counts <- sapply(merged_df, count_duplicates)

# Create a summary df for merged_df
merged_df_summary <- data.frame(
  n = nrow(merged_df),
  missing = colSums(is.na(merged_df)),
  perc_complete = round((((nrow(merged_df) - colSums(is.na(merged_df))) / nrow(merged_df)) * 100), 2),
  distinct = sapply(merged_df, function(x) length(unique(x))),
  duplicates = duplicate_counts
)

# print 
kable(head(merged_df_summary), caption = 'Summary for each variable in merged_df') %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Create Agreement patterns for dob, sex, soundex

```{r}
# New variables showing agreement patterns 
merged_df$agree_dob <- ifelse(merged_df$P_dob == merged_df$L_dob, 1,0)
merged_df$agree_sex <- ifelse(merged_df$P_sex == merged_df$L_sex, 1,0)
merged_df$agree_soundex <- ifelse(merged_df$P_soundex == merged_df$L_soundex, 1,0)

merged_df$agreement_pattern <- paste(merged_df$agree_dob, merged_df$agree_sex, merged_df$agree_soundex, sep = "")

# Subset merged_df to select only the last 4 columns
subset_df <- merged_df[, (ncol(merged_df) - 3):ncol(merged_df)]

# Create the table using kable
kable(head(subset_df, n= 5, caption = 'Agreement patterns')) %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

### Agreement pattern summary

```{r}
# Function to summarise columns 
summarise_columns <- function(data_frame, column_names) {
  result_list <- list()  # Initialize an empty list to store results
  
  for (column_name in column_names) {
    total_rows <- nrow(data_frame)
    counts <- as.data.frame(table(data_frame[[column_name]]))
    colnames(counts) <- c(column_name, "Count")
    counts$Percentage <- (counts$Count / sum(counts$Count)) * 100
    result_list[[column_name]] <- counts  # Store result in the list
  }
  return(result_list)
}

# Call function on "agreement_pattern"
result_list <- summarise_columns(merged_df, "agreement_pattern")
summary_df <- do.call(rbind, result_list)

# Create the table using kable
kable(summary_df, caption = 'Summary of agreement patterns') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Calculate matched (m-probabilities)

Referring to the summary tables for each of the variables dob, sex, soundex, the match probabilities calculated as follows:

```{r}
# Dob
freq_table <- table(merged_df$agree_dob)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Agreement patterns: dob') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

```{r, echo=FALSE}
# Sex
freq_table <- table(merged_df$agree_sex)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Agreement patterns: sex') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

```{r, echo=FALSE}
# Soundex
freq_table <- table(merged_df$agree_soundex)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Agreement patterns: soundex') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

### Store m-probabilities

```{r}
# Function to calculate the count of rows where column value == 1 as a proportion
calc_proportion <- function(data_frame, column_name) {
  total_rows <- nrow(data_frame)
  count_ones <- sum(data_frame[[column_name]] == 1)
  prop <- count_ones / total_rows
  proportion <- as.numeric(format(prop, nsmall = 2))
  return(proportion)
}

columns_to_iterate <- c("agree_dob", "agree_sex", "agree_soundex")

## Print Table 
# Create an empty df to store the results
m_prob_df <- data.frame(Column = character(0), m_prob = numeric(0))

for (column_name in columns_to_iterate) {
  proportion <- calc_proportion(merged_df, column_name)
  
  # Add a new row to m_prob_df
  m_prob_df <- rbind(m_prob_df, data.frame(Column = column_name, m_prob = proportion))
}

# Print df
kable(m_prob_df, caption = 'm_prob: % agree == 1') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")


## Create variables for m_probs
dob_mprob <- calc_proportion(merged_df, "agree_dob")
sex_mprob <- calc_proportion(merged_df, "agree_sex")
soundex_mprob <- calc_proportion(merged_df, "agree_soundex")
```

## Calculate unmatched (u-probabilities) using df_primary

-   u-probabilities are the probability of agreeing on an identifier by chance.

-   Calculated using 1/(number of unique counts) for variables: sex, dob, soundex.

-   However, you could also use joinby on a sample of id1 and id2 to create a random sample.

```{r}
# Create variables for u-probs
dob_uprob <- as.numeric(sprintf("%.10f", (1/length(unique(df_primary$P_dob)))))
sex_uprob <- as.numeric(sprintf("%.10f", (1/length(unique(df_primary$P_sex)))))
soundex_uprob <- as.numeric(sprintf("%.10f", (1/length(unique(df_primary$P_soundex)))))

# Create a new dataframe and store the results as u_prob_df
u_prob_df <- data.frame(
  Column = c("P_dob", "P_sex", "P_soundex"),
  unique_values = c(length(unique(df_primary$P_dob)), length(unique(df_primary$P_sex)), length(unique(df_primary$P_soundex))),
  u_prob = c(dob_uprob, sex_uprob, soundex_uprob)
)

# Print the u_prob_df
kable(u_prob_df, caption = 'u_prob: 1/unique_values') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")


```

------------------------------------------------------------------------

# Probabilistic linkage for remaining comparison pairs, using 'year' as blocking variable

Merging df_linking with itself results in a large number of comparisons

```{r}
# Merging df_linking with itself results in:
num_records <- nrow(df_linking)
cat("Total comparison pairs:", num_records*num_records, "\n") 
```

## Blocking on 'year'

To reduce the number of comparison pairs, we generate comparison pairs that do not agree on NHS number, by merging df_linking with df_primary and blocking on the 'year' variable.

```{r}
# Merge df_primary and df_linking based on the 'year' variable
merged_yr_df <- merge(df_linking, df_primary, by.x = "L_year", by.y = "P_year")
# print(names(merged_df2))

# Reorder the columns in 'merged_df2'
desired_order <- c("P_id1", "L_id2", "L_year", "P_dob", "L_dob","P_sex", "L_sex", "P_soundex", "L_soundex", "L_date1", "L_date2", "P_nhs","L_nhs")

merged_yr_df <- merged_yr_df %>%
  select(all_of(desired_order))

# Sort by ids
sorted_indices <- order(merged_yr_df$P_id1, merged_yr_df$L_id2)
merged_yr_df <- merged_yr_df[sorted_indices, ]
rm(sorted_indices)


kable(head(merged_yr_df, n=5), caption = 'merged_yr_df blocked by year, Top 5 rows. (Note: P_year is automatically removed during process)') %>%
kable_styling(bootstrap_options = c("striped"), full_width = T, position = "left")


```

### Comparison space reduced through blocking

```{r}
# Calculate values
num_df_linking <- nrow(df_linking)
num_merged_yr_df <- nrow(merged_yr_df)
comparison_space <- (num_df_linking * num_df_linking)
reduction_blocking <- comparison_space - num_merged_yr_df

summary_df <- data.frame(
  Dataset = c("df_linking^2", "df_merged_yr", "Reduction(blocking)"),
  Num_comparisons = c(comparison_space, num_merged_yr_df, reduction_blocking)
)

# Print
kable(summary_df, caption = 'Reduction in comparison space') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Exclude records previously matched on NHS number

```{r}
merged_yr_df <- merged_yr_df %>%
  anti_join(merged_yr_df %>% filter(P_nhs == L_nhs & P_nhs != ""), 
            by = c("P_nhs", "L_nhs"))

# df
summary_df <- data.frame(
  Summary = c('Pre-filter', 'Post filter', 'Exclude'),
  Num_records = c(num_merged_yr_df, nrow(merged_yr_df), num_merged_yr_df - nrow(merged_yr_df)))

# Print
kable(summary_df, caption = 'Exclusion of matched records') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Generate agreement patterns for dob, sex, soundex

```{r}
# New variables showing agreement patterns 
merged_yr_df$agree_dob <- ifelse(merged_yr_df$P_dob == merged_yr_df$L_dob, 1,0)
merged_yr_df$agree_sex <- ifelse(merged_yr_df$P_sex == merged_yr_df$L_sex, 1,0)
merged_yr_df$agree_soundex <- ifelse(merged_yr_df$P_soundex == merged_yr_df$L_soundex, 1,0)

merged_yr_df$agreement_pattern <- paste(merged_yr_df$agree_dob, merged_yr_df$agree_sex, merged_yr_df$agree_soundex, sep = "")

# Subset merged_df to select only the last 4 columns
subset_yr_df <- merged_yr_df[, (ncol(merged_yr_df) - 3):ncol(merged_yr_df)]

# Create the table using kable
kable(head(subset_yr_df, n= 5, caption = 'Agreement patterns')) %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Select specific variables into a new merged_yr_df2

```{r}
# New dfmerged_yr_df2 
merged_yr_df2 <- merged_yr_df %>%
  select(P_id1, L_id2, L_date1, L_date2, agree_dob, agree_sex, agree_soundex, agreement_pattern)


kable(head(merged_yr_df2, n=5), caption = 'merged_yr_df2 Top 5 rows') %>%
kable_styling(bootstrap_options = c("striped"), full_width = T, position = "left")

```

### Tabulate agreement pattern

-   Use function created previously

```{r}
# Call function on "agreement_pattern"
result_list <- summarise_columns(merged_yr_df2, "agreement_pattern")
summary_df <- do.call(rbind, result_list)

# Create the table using kable
kable(summary_df, caption = 'Summary of agreement patterns') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Applying m probabilities to merged_yr_df2

-   Use m-probabilities from gold standard for agreement

-   Use 1-m-probability for disagreement

```{r}
# Create m-probs
merged_yr_df2$mprob_dob <- ifelse(merged_yr_df2$agree_dob == 1, dob_mprob, (1-dob_mprob))
merged_yr_df2$mprob_sex <- ifelse(merged_yr_df2$agree_sex == 1, sex_mprob, (1-sex_mprob))
merged_yr_df2$mprob_soundex <- ifelse(merged_yr_df2$agree_soundex == 1, soundex_mprob, (1-soundex_mprob))
print("Task completed")
```

## Applying u probabilities to merged_yr_df2

-   Use u-probabilities for agreement

-   Use 1-u probability for disagreement

```{r}
# Create u-probs
merged_yr_df2$uprob_dob <- ifelse(merged_yr_df2$agree_dob == 1, dob_uprob, (1-dob_uprob))
merged_yr_df2$uprob_sex <- ifelse(merged_yr_df2$agree_sex == 1, sex_uprob, (1-sex_uprob))
merged_yr_df2$uprob_soundex <- ifelse(merged_yr_df2$agree_soundex == 1, soundex_uprob, (1-soundex_uprob))
print("Task completed")
```

## Calculate ratio (m-prob/u-prob)

```{r}
# Calculate match ratios
merged_yr_df2$r_dob <- merged_yr_df2$mprob_dob / merged_yr_df2$uprob_dob 
merged_yr_df2$r_sex <- merged_yr_df2$mprob_sex / merged_yr_df2$uprob_sex 
merged_yr_df2$r_soundex <- merged_yr_df2$mprob_soundex / merged_yr_df2$uprob_soundex 
print("Task completed")
```

## Calculate weights log2(ratio)/log2(2)

```{r}
# Calculate match weights 
merged_yr_df2$w_dob <-   log2(merged_yr_df2$r_dob)/log2(2)
merged_yr_df2$w_sex <-   log2(merged_yr_df2$r_sex)/log2(2)
merged_yr_df2$w_soundex <-  log2(merged_yr_df2$r_soundex)/log2(2)
print("Task completed")
```

## Generate overall match weight: Sum(weights)

```{r}
# Create match weight 
merged_yr_df2$W <-(merged_yr_df2$w_dob + merged_yr_df2$w_sex + merged_yr_df2$w_soundex)
print("Task completed")
```

## Check individual weights: dob, sex, soundex, W

```{r}
# Dob 
freq_table <- table(merged_yr_df2$w_dob)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Match weight: dob') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

```{r, echo=FALSE}
# Sex
freq_table <- table(merged_yr_df2$w_sex)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Match weight: sex') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

```{r, echo=FALSE}
# Soundex
freq_table <- table(merged_yr_df2$w_soundex)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Match weight: soundex') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

```{r, echo=FALSE}
# W
freq_table <- table(merged_yr_df2$W)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Match weight: W') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Check agreement patterns and overall match weights

```{r message=FALSE}
# Select the columns id1, id2, W, and agreement_pattern
merged_yr_df3 <- merged_yr_df2 %>%
  select(P_id1, L_id2, agreement_pattern, W)

# Create a new data frame by collapsing (count) id1 by W and agree
merged_yr_df4 <- merged_yr_df3 %>%
  group_by(agreement_pattern, W) %>%
  summarize(count = n()) %>%
  arrange(W)

kable(merged_yr_df4, caption = 'Agreement pattern & Match weight (W)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

### Plot: Agreement pattern & Match weight (W)

```{r}
# Combine "Agreement Pattern" and "W" for x-axis labels
merged_yr_df4$label <- paste(merged_yr_df4$agreement_pattern, " (W =", round(merged_yr_df4$W, 2), ")", sep = "")

merged_yr_df4$label <- gsub("\\(", "\n(", merged_yr_df4$label)
merged_yr_df4$label <- reorder(merged_yr_df4$label, merged_yr_df4$W)

# Create the bar chart with log-scaled y-axis and data labels
ggplot(merged_yr_df4, aes(x = label, y = count, fill = agreement_pattern)) +
  geom_col() +
  geom_text(aes(label = count), vjust = -0.5, size = 3) +  
  labs(x = "Agreement Pattern (Weight)", y = "Count (log scale)", title = "Fig 1. Agreement patterns & Match weights") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5)) + 
  scale_y_log10() +
  guides(fill = "none")
```

## For each primary file record, keep highest weighted candidate linking records

-   Filter rows where W is greater than or equal to 0

-   Sort the dataframe by id1 and -W

-   Add a column 'n' within each id1 group

-   Add a column 'N' within each id1 group (assuming you want to count total observations per group)

-   Keep only rows where n equals 1

```{r}
# Create new df 
merged_yr_df5 <- merged_yr_df3
merged_yr_df5 <- merged_yr_df5[merged_yr_df5$W >= 0, ]
merged_yr_df5 <- merged_yr_df5[order(merged_yr_df5$P_id1, -merged_yr_df5$W), ]
merged_yr_df5$n <- ave(seq_along(merged_yr_df5$P_id1), merged_yr_df5$P_id1, FUN = seq_along)
merged_yr_df5$N <- ave(seq_along(merged_yr_df5$P_id1), merged_yr_df5$P_id1, FUN = length)
merged_yr_df5 <- merged_yr_df5[merged_yr_df5$n == 1,]

kable(head(merged_yr_df5,n=10), caption = 'Example agreement patterns (Top 10 rows)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

------------------------------------------------------------------------

# Choose thresholds for manual review

## Merge dataframes: 'merged_yr_df5' & 'df_linking'

```{r}
# Merge with df_linking
merged_yr_df6 <- merge(merged_yr_df5, df_linking, by.x = "L_id2", by.y = "L_id2", all.x = TRUE)

# Specify variables 
merged_yr_df6 <- merged_yr_df6 %>%
  select(P_id1,L_id2,agreement_pattern,W,L_dob,L_sex,L_soundex,L_date1,L_date2)

kable(head(merged_yr_df6, n=5), caption = 'Merged dataframe (Top 5 rows)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Merge dataframes: 'merged_yr_df6' & 'df_primary'

-   Sort by W descending

```{r}
# Merge with df_primary
merged_yr_df6 <- merge(merged_yr_df6, df_primary, by.x = "P_id1", by.y = "P_id1", all.x = TRUE)

# Keep only the specified columns
merged_yr_df6 <- merged_yr_df6 %>%
  select(P_id1,L_id2,L_date1,L_date2,W,agreement_pattern,P_dob,L_dob,P_sex,L_sex,P_soundex,L_soundex)

merged_yr_df6 <- merged_yr_df6 %>%
  arrange(desc(W))

kable(head(merged_yr_df6, n=10), caption = 'Merged dataframe (Top 10 rows)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

### Plot: Weight

```{r}
# Create a histogram of the 'W' variable
hist(merged_yr_df6$W, main = "Fig 2.Histogram: Weight",xlab = "Weight",ylab = "Frequency",col = "lightblue")
```

## Manual review and decide on thresholds

-   Keep specific variables

-   Sort by id2 and -W, and then by date1

-   Generate a new variable 'n' that contains the sequential count within each 'id2' group

```{r}
merged_yr_df7 <- merged_yr_df6 %>%
  select(P_id1,L_id2,L_date1,L_date2,W,agreement_pattern)

merged_yr_df7 <- merged_yr_df7 %>%
  arrange(L_id2, desc(W), L_date1)

merged_yr_df7 <- merged_yr_df7 %>%
  group_by(L_id2) %>%
  mutate(n = row_number()) %>%
  ungroup()

print("Task completed")
```

### Example focusing on L_id2 = 26

```{r}
# Use subset to filter rows where L_id2 is 26 or 41
filtered_df <- subset(merged_yr_df7, L_id2 %in% c(26, 41, 50, 53))

kable(head(filtered_df, n=10), caption = 'merged_yr_df7 (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

Summary

-   L_id2 '26' was compared against two values for P_id1.

-   Data were ordered by descending Weight, so that n of 1 always reflects the highest weight.

-   The agreement pattern provides additional information on matches between dob, sex, soundex.

-   Other example L_id2s have been included to further illustrate this point.

## Keep matches where n=1

```{r}
df_matched_ids <- merged_yr_df7[merged_yr_df7$n == 1, ]

# Sort by id1
df_matched_ids <- df_matched_ids %>%
  arrange(P_id1)


kable(head(df_matched_ids, n=10), caption = 'Matches where n=1 (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Reshaping the dataframe for one event per row

-   To address variables L_date1 and L_date2, we use the pivot.longer function to reshape the dataframe from wide to long.

```{r}
df_matched_ids_long <- df_matched_ids %>%
  pivot_longer(
    cols = starts_with("L_date"), # Columns to reshape
    names_to = "date",       # New variable name
    values_to = "date_value"     # New value column name
  )

kable(head(df_matched_ids_long, n=10), caption = 'Reshaped df combining date variables (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Remove all records where date value is blank

```{r}
df_matched_final <- df_matched_ids_long %>%
  filter(date_value != "")

# Keep only the specified columns
df_matched_final <- df_matched_final %>%
  select(P_id1, L_id2, date = date_value, W) %>%
  arrange(P_id1)

kable(head(df_matched_final, n=10), caption = 'Remove all blank dates (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

### Density plot: W

-   Visualise the distribution of weight (W)

```{r}
ggplot(df_matched_final, aes(x = W)) +
  geom_density(fill = "lightblue", color = "black") +
  labs(title = "Fig 3.Density Plot: Weight", x = "Weight(W)", y = "Density")
```

## Calculate the number of events per person (N)

-   Calculate the number of events (N) per person (P_id1)

```{r}
df_matched_final <- df_matched_final %>%
  group_by(P_id1) %>%
  mutate(N = n()) %>%
  ungroup()

print("Task completed")
```

### Events per person

```{r}

summary_df <- df_matched_final %>%
  group_by(N) %>%
  summarise(Frequency = n()) %>%
  mutate(Percentage = (Frequency / sum(Frequency)) * 100)

# Create a table with kable
kable(summary_df, caption = 'Number of events per person') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

### Matched records

-   Looking at P_id1 = 6 matches to L_id2 = 1027

-   However, we observe that dates are different 11oct1999 and 17jan2000 which explains why variable N is 2.

-   Overall approximately 39% of matched ids have 1 row, however, 61% have 2 rows (due to \>1 date recorded).

```{r}
kable(head(df_matched_final, n=10), caption = 'Number of events per person (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left") 
```

------------------------------------------------------------------------

# Complete
