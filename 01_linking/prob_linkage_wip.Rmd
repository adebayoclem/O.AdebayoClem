---
title: "Linking ECDS with sentinel data"
date: "Feb 2024"
output: 
  html_document:
    number_sections: yes
    toc: yes
    theme: cerulean 
pdf_document:
  toc: yes
---

------------------------------------------------------------------------

# Setup

## Import R libraries

```{r packages, message=FALSE}
# Import libraries
pacman::p_load(
  pacman,
  tidyverse,
  readxl,
  writexl,
  DBI,
  odbc,
  knitr,
  data.table,
  kableExtra,
  janitor,
  report,
  naniar
)
```

## Import and clean data

```{r dataclean}
source("cleaning_for_linkage.R")
```

## View data completeness and uniqueness
```{r ECDS_summary_view}
ECDS_summary
```

```{r SGSS_summary_view}
SGSS_summary
```

-   NHS number is complete for `r prop_complete(ECDS_clean_nop$nhs_number)`% of records in ECDS and `r prop_complete(SGSS_clean_nop$nhs_number`% of records in SGSS. This will facilitate 'Deterministic Linkage'.

-   Assumption for this exercise is that the NHS number is unique and correct.

-   We will link both datasets using available NHS numbers to create subset that contains 'comparison pairs'.

-   This subset can be used as a 'Gold-standard' from which m & u probabilities can be calculated.

## Naming conventions

-   Note that both datasets contain variables with the same naming convention, which will cause confusion when identifying these variables after linkage.

-   Therefore, one approach to overcome this, is to add a prefix to each variable:

    -   For variables in Primary file add P\_

    -   For variables in Linking file add L\_
    
- The names have been formatted like this in ECDS_clean and SGSS_clean

# Deterministic linkage with NHS number

-   Perform a cross-join on the NHS number, where P_nhs == L_nhs.
-   Reorder columns & sort by ascending ids

```{r}
rm(list=setdiff(ls(), c("ECDS_clean_nop", "SGSS_clean_nop", "ECDS_clean", "SGSS_clean"))) # removes all unused objects to save memory

# Merge df_primary and df_linking based on the 'nhs' variable
merged_df <- merge(SGSS_clean, ECDS_clean, by.x = "L_nhs_number", by.y = "P_nhs_number", incomparables = NA) %>%
  select("P_id", 
         "L_id", 
         "L_nhs_number", 
         "P_birth_date", 
         "L_birth_date",
         "P_postcode",
         "L_postcode",
         "P_sex", 
         "L_sex",
         "P_date",
         "L_date")


# Sort
sorted_indices <- order(merged_df$P_id, merged_df$L_id)
merged_df <- merged_df[sorted_indices, ]
rm(sorted_indices)

# No output
```

## Linkage summary

```{r}
# Function
count_info <- function(data_frame, nhs_column) {
  df_name <- deparse(substitute(data_frame))
  num_rows <- nrow(data_frame)
  num_columns <- ncol(data_frame)
  nhs_counts <- table(data_frame[[nhs_column]])
  
  result <- data.frame(
    DF = df_name,
    Num_Columns = num_columns,
    Num_Rows = num_rows,
    NHS_Column_Rows = sum(nhs_counts)
  )
  return(result)
}

# Apply function & Combine dfs
df_linking_info <- count_info(SGSS_clean, "L_nhs_number")
df_primary_info <- count_info(ECDS_clean, "P_nhs_number")
merged_df_info <- count_info(merged_df, "L_nhs_number")
summary_df <- rbind(df_linking_info, df_primary_info, merged_df_info)

kable(head(summary_df), caption = 'Summary') %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## View merged_df

```{r}
kable(head(merged_df, n=5), caption = 'Merged_df: Top 5 rows. (Note: P_nhs_number is automatically removed during process).') %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Summary merged_df

Obtain a summary for merged_df, focus on duplicates for P_id1 and L_id2

```{r}
# Function to count duplicate values in a column
count_duplicates <- function(x) {
  sum(duplicated(x) | duplicated(x, fromLast = TRUE))
}

# Count duplicates for each column
duplicate_counts <- sapply(merged_df, count_duplicates)

# Create a summary df for merged_df
merged_df_summary <- data.frame(
  n = nrow(merged_df),
  missing = colSums(is.na(merged_df)),
  perc_complete = round((((nrow(merged_df) - colSums(is.na(merged_df))) / nrow(merged_df)) * 100), 2),
  distinct = sapply(merged_df, function(x) length(unique(x))),
  duplicates = duplicate_counts
)

# print 
kable(head(merged_df_summary), caption = 'Summary for each variable in merged_df') %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Create Agreement patterns for dob, postcode, sex, date

```{r}
# New variables showing agreement patterns 
merged_df$agree_dob <- if_else(merged_df$P_birth_date == merged_df$L_birth_date, 1,0,0)
merged_df$agree_sex <- if_else(merged_df$P_sex == merged_df$L_sex, 1,0,0)
merged_df$agree_pcode <- if_else(merged_df$P_postcode == merged_df$L_postcode, 1,0,0)
merged_df$agree_date <- if_else(merged_df$P_date == merged_df$L_date, 1,0,0)

merged_df$agreement_pattern <- paste(merged_df$agree_dob, merged_df$agree_pcode, merged_df$agree_sex, merged_df$agree_date, sep = "")

# Subset merged_df to select only the last 4 columns
subset_df <- merged_df %>%
  select(agree_dob, agree_pcode, agree_sex, agree_date, agreement_pattern)

# Create the table using kable
kable(head(subset_df, n= 5, caption = 'Agreement patterns')) %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

### Agreement pattern summary

```{r}
# Function to summarise columns 
summarise_columns <- function(data_frame, column_names) {
  result_list <- list()  # Initialize an empty list to store results
  
  for (column_name in column_names) {
    total_rows <- nrow(data_frame)
    counts <- as.data.frame(table(data_frame[[column_name]]))
    colnames(counts) <- c(column_name, "Count")
    counts$Percentage <- (counts$Count / sum(counts$Count)) * 100
    result_list[[column_name]] <- counts  # Store result in the list
  }
  return(result_list)
}

# Call function on "agreement_pattern"
result_list <- summarise_columns(merged_df, "agreement_pattern")
summary_df <- do.call(rbind, result_list)

# Create the table using kable
kable(summary_df, caption = 'Summary of agreement patterns') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Calculate matched (m-probabilities)

Referring to the summary tables for each of the variables dob, sex, postcode, date the match probabilities calculated as follows:

```{r}
# Dob
freq_table <- table(merged_df$agree_dob)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Agreement patterns: dob') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

```{r, echo=FALSE}
# Postcode
freq_table <- table(merged_df$agree_pcode)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Agreement patterns: postcode') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

```{r, echo=FALSE}
# Sex
freq_table <- table(merged_df$agree_sex)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Agreement patterns: sex') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

```{r, echo=FALSE}
# Date
freq_table <- table(merged_df$agree_date)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Agreement patterns: date') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```
### Store m-probabilities

```{r}
# Function to calculate the count of rows where column value == 1 as a proportion
calc_proportion <- function(data_frame, column_name) {
  total_rows <- nrow(data_frame)
  count_ones <- sum(data_frame[[column_name]] == 1)
  prop <- count_ones / total_rows
  proportion <- as.numeric(format(prop, nsmall = 2))
  return(proportion)
}

columns_to_iterate <- c("agree_dob", "agree_pcode", "agree_sex", "agree_date")

## Print Table 
# Create an empty df to store the results
m_prob_df <- data.frame(Column = character(0), m_prob = numeric(0))

for (column_name in columns_to_iterate) {
  proportion <- calc_proportion(merged_df, column_name)
  
  # Add a new row to m_prob_df
  m_prob_df <- rbind(m_prob_df, data.frame(Column = column_name, m_prob = proportion))
}

# Print df
kable(m_prob_df, caption = 'm_prob: % agree == 1') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")


## Create variables for m_probs
dob_mprob <- calc_proportion(merged_df, "agree_dob")
pcode_mprob <- calc_proportion(merged_df, "agree_pcode")
sex_mprob <- calc_proportion(merged_df, "agree_sex")
date_mprob <- calc_proportion(merged_df, "agree_date")
```

## Calculate unmatched (u-probabilities) using df_primary

-   u-probabilities are the probability of agreeing on an identifier by chance.

-   Calculated using 1/(number of unique counts) for variables: sex, dob, soundex.

-   However, you could also use joinby on a sample of id1 and id2 to create a random sample.

```{r}
# Create variables for u-probs
dob_uprob <- as.numeric(sprintf("%.10f", (1/length(unique(ECDS_clean$P_birth_date)))))
pcode_uprob <- as.numeric(sprintf("%.10f", (1/length(unique(ECDS_clean$P_postcode)))))
sex_uprob <- as.numeric(sprintf("%.10f", (1/length(unique(ECDS_clean$P_sex)))))
date_uprob <- as.numeric(sprintf("%.10f", (1/length(unique(ECDS_clean$P_date)))))

# Create a new dataframe and store the results as u_prob_df
u_prob_df <- data.frame(
  Column = c("P_birth_date", "P_postcode", "P_sex", "P_date"),
  unique_values = c(length(unique(ECDS_clean$P_birth_date)), length(unique(ECDS_clean$P_postcode)), length(unique(ECDS_clean$P_sex)), length(unique(ECDS_clean$P_birth))),
  u_prob = c(dob_uprob, pcode_uprob, sex_uprob, date_uprob)
)

# Print the u_prob_df
kable(u_prob_df, caption = 'u_prob: 1/unique_values') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

------------------------------------------------------------------------

# Probabilistic linkage for remaining comparison pairs, using 'year' as blocking variable

Merging df_linking with itself results in a large number of comparisons

```{r}
# Merging df_linking with itself results in:
num_records <- nrow(SGSS_clean)
cat("Total comparison pairs:", num_records*num_records, "\n") 
```

## Blocking on 'birth_date'

To reduce the number of comparison pairs, we generate comparison pairs that do not agree on NHS number, by merging df_linking with df_primary and blocking on the 'birth_date' variable.

```{r}
# Merge df_primary and df_linking based on the 'date' variable
merged_dob_df <- merge(SGSS_clean, ECDS_clean, by.x = "L_birth_date", by.y = "P_birth_date")
# print(names(merged_df2))

# Reorder the columns in 'merged_df2'
merged_dob_df <- merged_dob_df %>%
  select(
    "P_id",
    "L_id",
    "L_date",
    "P_date",
    "L_birth_date",
    "P_sex",
    "L_sex",
    "P_postcode",
    "L_postcode",
    "P_nhs_number",
    "L_nhs_number"
  )

# Sort by ids
sorted_indices <- order(merged_dob_df$P_id, merged_dob_df$L_id)
merged_dob_df <- merged_dob_df[sorted_indices, ]
rm(sorted_indices)


kable(head(merged_dob_df, n=5), caption = 'merged_dob_df blocked by date, Top 5 rows. (Note: P_date is automatically removed during process)') %>%
kable_styling(bootstrap_options = c("striped"), full_width = T, position = "left")
```

### Comparison space reduced through blocking

```{r}
# Calculate values
num_df_linking <- nrow(SGSS_clean)
num_merged_dob_df <- nrow(merged_dob_df)
comparison_space <- (num_df_linking * num_df_linking)
reduction_blocking <- comparison_space - num_merged_dob_df

summary_df <- data.frame(
  Dataset = c("SGSS_clean^2", "df_merged_yr", "Reduction(blocking)"),
  Num_comparisons = c(comparison_space, num_merged_dob_df, reduction_blocking)
)

# Print
kable(summary_df, caption = 'Reduction in comparison space') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Exclude records previously matched on NHS number

```{r}
merged_dob_df <- merged_dob_df %>%
  anti_join(merged_dob_df %>% filter(P_nhs_number == L_nhs_number & P_nhs_number != ""), 
            by = c("P_nhs_number", "L_nhs_number"))

# df
summary_df <- data.frame(
  Summary = c('Pre-filter', 'Post filter', 'Exclude'),
  Num_records = c(num_merged_dob_df, nrow(merged_dob_df), num_merged_dob_df - nrow(merged_dob_df)))

# Print
kable(summary_df, caption = 'Exclusion of matched records') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Generate agreement patterns for date, sex, postcode

```{r}
# New variables showing agreement patterns 
merged_dob_df$agree_pcode <- if_else(merged_dob_df$P_postcode == merged_dob_df$L_postcode, 1,0,0)
merged_dob_df$agree_sex <- if_else(merged_dob_df$P_sex == merged_dob_df$L_sex, 1,0,0)
merged_dob_df$agree_date <- if_else(merged_dob_df$P_date == merged_dob_df$L_date, 1,0,0)

merged_dob_df$agreement_pattern <- paste(merged_dob_df$agree_dob, merged_dob_df$agree_pcode, merged_dob_df$agree_sex, merged_dob_df$agree_date, sep = "")

# Subset merged_df to select only the last 4 columns
subset_dob_df <- merged_dob_df %>%
  select(agree_pcode,
         agree_sex,
         agree_date,
         agreement_pattern)

# Create the table using kable
kable(head(subset_dob_df, n= 5, caption = 'Agreement patterns')) %>%
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Select specific variables into a new merged_dob_df2

```{r}
# New dfmerged_dob_df2 
merged_dob_df2 <- merged_dob_df %>%
  select(P_id, L_id, agree_pcode, agree_sex, agree_date, agreement_pattern)


kable(head(merged_dob_df2, n=5), caption = 'merged_dob_df2 Top 5 rows') %>%
kable_styling(bootstrap_options = c("striped"), full_width = T, position = "left")

```

### Tabulate agreement pattern

-   Use function created previously

```{r}
# Call function on "agreement_pattern"
result_list <- summarise_columns(merged_dob_df2, "agreement_pattern")
summary_df <- do.call(rbind, result_list)

# Create the table using kable
kable(summary_df, caption = 'Summary of agreement patterns') %>% 
kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Applying m probabilities to merged_dob_df2

-   Use m-probabilities from gold standard for agreement

-   Use 1-m-probability for disagreement

```{r}
# Create m-probs
merged_dob_df2$mprob_pcode <- ifelse(merged_dob_df2$agree_pcode == 1, pcode_mprob, (1-pcode_mprob))
merged_dob_df2$mprob_sex <- ifelse(merged_dob_df2$agree_sex == 1, sex_mprob, (1-sex_mprob))
merged_dob_df2$mprob_date <- ifelse(merged_dob_df2$agree_date == 1, date_mprob, (1-date_mprob))
print("Task completed")
```

## Applying u probabilities to merged_dob_df2

-   Use u-probabilities for agreement

-   Use 1-u probability for disagreement

```{r}
# Create u-probs
merged_dob_df2$uprob_pcode <- ifelse(merged_dob_df2$agree_pcode == 1, pcode_uprob, (1-pcode_uprob))
merged_dob_df2$uprob_sex <- ifelse(merged_dob_df2$agree_sex == 1, sex_uprob, (1-sex_uprob))
merged_dob_df2$uprob_date <- ifelse(merged_dob_df2$agree_date == 1, date_uprob, (1-date_uprob))
print("Task completed")
```

## Calculate ratio (m-prob/u-prob)

```{r}
# Calculate match ratios
merged_dob_df2$r_pcode <- merged_dob_df2$mprob_pcode / merged_dob_df2$uprob_pcode 
merged_dob_df2$r_sex <- merged_dob_df2$mprob_sex / merged_dob_df2$uprob_sex 
merged_dob_df2$r_date <- merged_dob_df2$mprob_date / merged_dob_df2$uprob_date 
print("Task completed")
```

## Calculate weights log2(ratio)/log2(2)

```{r}
# Calculate match weights 
merged_dob_df2$w_pcode <-   log2(merged_dob_df2$r_pcode)/log2(2)
merged_dob_df2$w_sex <-   log2(merged_dob_df2$r_sex)/log2(2)
merged_dob_df2$w_date <-  log2(merged_dob_df2$r_date)/log2(2)
print("Task completed")
```

## Generate overall match weight: Sum(weights)

```{r}
# Create match weight 
merged_dob_df2$W <-(merged_dob_df2$w_pcode + merged_dob_df2$w_sex + merged_dob_df2$w_date)
print("Task completed")
```

## Check individual weights: postcode, sex, date, W

```{r}
# Postcode
freq_table <- table(merged_dob_df2$w_pcode)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Match weight: postcode') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

```{r, echo=FALSE}
# Sex
freq_table <- table(merged_dob_df2$w_sex)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Match weight: sex') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

```{r, echo=FALSE}
# Date
freq_table <- table(merged_dob_df2$w_date)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Match weight: date') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

```{r, echo=FALSE}
# W
freq_table <- table(merged_dob_df2$W)
freq_df <- as.data.frame(freq_table)
colnames(freq_df) <- c("Value", "Frequency")
freq_df$Percentage <- (freq_df$Frequency / sum(freq_df$Frequency)) * 100

kable(freq_df, caption = 'Match weight: W') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

## Check agreement patterns and overall match weights

```{r message=FALSE}
# Select the columns id1, id2, W, and agreement_pattern
merged_dob_df3 <- merged_dob_df2 %>%
  select(P_id, L_id, agreement_pattern, W)

# Create a new data frame by collapsing (count) id1 by W and agree
merged_dob_df4 <- merged_dob_df3 %>%
  group_by(agreement_pattern, W) %>%
  summarize(count = n()) %>%
  arrange(W)

kable(merged_dob_df4, caption = 'Agreement pattern & Match weight (W)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

### Plot: Agreement pattern & Match weight (W)

```{r}
# Combine "Agreement Pattern" and "W" for x-axis labels
merged_dob_df4$label <- paste(merged_dob_df4$agreement_pattern, " (W =", round(merged_dob_df4$W, 2), ")", sep = "")

merged_dob_df4$label <- gsub("\\(", "\n(", merged_dob_df4$label)
merged_dob_df4$label <- reorder(merged_dob_df4$label, merged_dob_df4$W)

# Create the bar chart with log-scaled y-axis and data labels
ggplot(merged_dob_df4, aes(x = label, y = count, fill = agreement_pattern)) +
  geom_col() +
  geom_text(aes(label = count), vjust = -0.5, size = 3) +  
  labs(x = "Agreement Pattern (Weight)", y = "Count (log scale)", title = "Fig 1. Agreement patterns & Match weights") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5)) + 
  scale_y_log10() +
  guides(fill = "none")
```

## For each primary file record, keep highest weighted candidate linking records

-   Filter rows where W is greater than or equal to 0

-   Sort the dataframe by id and -W

-   Add a column 'n' within each id group

-   Add a column 'N' within each id group (assuming you want to count total observations per group)

-   Keep only rows where n equals 1

```{r}
# Create new df 
merged_dob_df5 <- merged_dob_df3
merged_dob_df5 <- merged_dob_df5[merged_dob_df5$W >= 0, ]
merged_dob_df5 <- merged_dob_df5[order(merged_dob_df5$P_id, -merged_dob_df5$W), ]
merged_dob_df5$n <- ave(seq_along(merged_dob_df5$P_id), merged_dob_df5$P_id, FUN = seq_along)
merged_dob_df5$N <- ave(seq_along(merged_dob_df5$P_id), merged_dob_df5$P_id, FUN = length)
merged_dob_df5 <- merged_dob_df5[merged_dob_df5$n == 1,]

kable(head(merged_dob_df5,n=10), caption = 'Example agreement patterns (Top 10 rows)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

------------------------------------------------------------------------

# Choose thresholds for manual review

## Merge dataframes: 'merged_dob_df5' & 'df_linking'

```{r}
# Merge with df_linking
merged_dob_df6 <- merge(merged_dob_df5, SGSS_clean, by.x = "L_id", by.y = "L_id", all.x = TRUE)

# Specify variables 
merged_dob_df6 <- merged_dob_df6 %>%
  select(P_id,L_id,agreement_pattern,W,L_birth_date,L_postcode,L_sex,L_date)

kable(head(merged_dob_df6, n=5), caption = 'Merged dataframe (Top 5 rows)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Merge dataframes: 'merged_dob_df6' & 'df_primary'

-   Sort by W descending

```{r}
# Merge with df_primary
merged_dob_df6 <- merge(merged_dob_df6, ECDS_clean, by.x = "P_id", by.y = "P_id", all.x = TRUE)

# Keep only the specified columns
merged_dob_df6 <- merged_dob_df6 %>%
  select(P_id,L_id,W,agreement_pattern,P_postcode,L_postcode,P_sex,L_sex,P_date,L_date)

merged_dob_df6 <- merged_dob_df6 %>%
  arrange(desc(W))

kable(head(merged_dob_df6, n=10), caption = 'Merged dataframe (Top 10 rows)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

### Plot: Weight

```{r}
# Create a histogram of the 'W' variable
hist(merged_dob_df6$W, main = "Fig 2.Histogram: Weight",xlab = "Weight",ylab = "Frequency",col = "lightblue")
```

## Manual review and decide on thresholds

-   Keep specific variables

-   Sort by id2 and -W, and then by date1

-   Generate a new variable 'n' that contains the sequential count within each 'id2' group

```{r}
merged_dob_df7 <- merged_dob_df6 %>%
  select(P_id,L_id,L_date,W,agreement_pattern)

merged_dob_df7 <- merged_dob_df7 %>%
  arrange(L_id, desc(W), L_date)

merged_dob_df7 <- merged_dob_df7 %>%
  group_by(L_id) %>%
  mutate(n = row_number()) %>%
  ungroup()

print("Task completed")
```

### Example focusing on L_id = 26

```{r}
# create row numbers
filtered_df <- merged_dob_df7 %>%
  mutate(rown = seq()
  
  subset(merged_dob_df7, L_id %in% c(26, 41, 50, 53))

kable(head(filtered_df, n=10), caption = 'merged_dob_df7 (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

Summary

-   L_id2 '26' was compared against two values for P_id1.

-   Data were ordered by descending Weight, so that n of 1 always reflects the highest weight.

-   The agreement pattern provides additional information on matches between dob, sex, soundex.

-   Other example L_id2s have been included to further illustrate this point.

## Keep matches where n=1

```{r}
df_matched_ids <- merged_dob_df7[merged_dob_df7$n == 1, ]

# Sort by id1
df_matched_ids <- df_matched_ids %>%
  arrange(P_id)


kable(head(df_matched_ids, n=10), caption = 'Matches where n=1 (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Reshaping the dataframe for one event per row

-   To address variables L_date1 and L_date2, we use the pivot.longer function to reshape the dataframe from wide to long.

```{r}
df_matched_ids_long <- df_matched_ids %>%
  pivot_longer(
    cols = starts_with("L_date"), # Columns to reshape
    names_to = "date",       # New variable name
    values_to = "date_value"     # New value column name
  )

kable(head(df_matched_ids_long, n=10), caption = 'Reshaped df combining date variables (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

## Remove all records where date value is blank

```{r}
df_matched_final <- df_matched_ids_long %>%
  filter(date_value != "")

# Keep only the specified columns
df_matched_final <- df_matched_final %>%
  select(P_id, L_id, date = date_value, W) %>%
  arrange(P_id)

kable(head(df_matched_final, n=10), caption = 'Remove all blank dates (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")
```

### Density plot: W

-   Visualise the distribution of weight (W)

```{r}
ggplot(df_matched_final, aes(x = W)) +
  geom_density(fill = "lightblue", color = "black") +
  labs(title = "Fig 3.Density Plot: Weight", x = "Weight(W)", y = "Density")
```

## Calculate the number of events per person (N)

-   Calculate the number of events (N) per person (P_id1)

```{r}
df_matched_final <- df_matched_final %>%
  group_by(P_id) %>%
  mutate(N = n()) %>%
  ungroup()

print("Task completed")
```

### Events per person

```{r}

summary_df <- df_matched_final %>%
  group_by(N) %>%
  summarise(Frequency = n()) %>%
  mutate(Percentage = (Frequency / sum(Frequency)) * 100)

# Create a table with kable
kable(summary_df, caption = 'Number of events per person') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left")

```

### Matched records

-   Looking at P_id1 = 6 matches to L_id2 = 1027

-   However, we observe that dates are different 11oct1999 and 17jan2000 which explains why variable N is 2.

-   Overall approximately 39% of matched ids have 1 row, however, 61% have 2 rows (due to \>1 date recorded).

```{r}
kable(head(df_matched_final, n=10), caption = 'Number of events per person (Top 10 records)') %>% 
  kable_styling(bootstrap_options = c("striped"), full_width = F, position = "left") 
```

------------------------------------------------------------------------

# Complete

