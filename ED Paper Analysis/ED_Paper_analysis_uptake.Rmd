---
title: "Logistic Regression Test Uptake"
author: "Olaide Adebayo-Clement"
date: "2024-05-20"
output: word_document
---

```{r setup, include=FALSE}

rm(list = ls(all.names = TRUE))

# This chunk sets up the R environment for the entire document.
# It includes the necessary libraries for data manipulation, visualization, and analysis.
# Set global chunk options
knitr::opts_chunk$set(
  echo = FALSE,        # Hide code in output
  error = FALSE,       # Show errors but don't stop rendering
  warning = FALSE,     # Hide warnings in output
  message = FALSE,     # Hide messages in output
  fig.width = 16.00,   # Set figure width
  fig.height = 13.00,   # Set figure height (calculated based on aspect ratio)
  fig.align = 'center',# Center align figures
  fig.topcaption = TRUE, # Place figure captions at the top
  out.width = '100%',  # Ensure figures use full width
  out.height = 'auto'  # Ensure figures maintain aspect ratio
)

# Install and load packages using pacman
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")

pacman::p_load(
  tidyverse,  # A collection of R packages for data science.
  readxl,     # For reading Excel files.
  DBI,        # Database interface for R.
  dplyr,      # A grammar of data manipulation.
  odbc,       # Connect to ODBC databases.
  janitor,    # For cleaning data.
  gtsummary,  # Create presentation-ready summary tables.
  scales,     # Tools for improving base R graphics.
  gt,         # Create table outputs.
  purrr,      # Functional programming tools.
  broom,      # Convert statistical analysis objects into tidy tibbles.
  here,       # For file referencing.
  readr,      # Reading rectangular data (like csv).
  car,        # For variance inflation factor (VIF) calculation.
  MASS,       # Functions and datasets to support Venables and Ripley's MASS.
  mice,        # For multiple imputation of missing data.
  forestplot,    
  stringr,
  tidyr,
  ggplot2,
  grid,
  gridExtra,
  ggpubr,
  stats,
  parallel,
  data.table,
  forcats,
  epiR,
  rpart,
  conflicted,
  doparallel,
  foreach,
  openxlsx,
  caret, # For cross-validation
  pROC,  # For AUC calculation
  lme4,
  glmmTMB,
  broom.mixed,
  geepack
  
)

# Handle package conflicts
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::recode)


```


```{r database-connection-and-load-data}
# Connect to the database using ODBC.
# This section establishes a connection to the database using the provided connection string.
Y006 <- odbc::dbConnect(
  odbc::odbc(),
  .connection_string = "driver={SQL Server};server=SQLClusColLK19\\Lake19;database=Y006_BBV_PID;Encrypt=true;trusted_connection=true",
  timeout = 60,
  timezone = Sys.timezone(),
  timezone_out = Sys.timezone()
)

```



```{r data-cleaning-and-preparation}

# Define a function to load attendees data from the database for a specific disease
load_attendees_data <- function(conn, disease) {
  query <- sprintf(
    "SELECT *, Site AS site_code
    FROM [Y006_BBV_PID].[dbo].[24mthECDSattendees_sentinelsites%s]
    WHERE (arrdate <= '2024-03-31')",
    disease
  )
  dbGetQuery(conn, query)
}

# Define a list of included sentinel sites
included_sites <- c('RYJ02', 'RQXM1', 'R0A02', 'R1HNH', 'R0A66', 'RJ231', 'E0A3H', 'RJ122', 'R1H12', 'RJ224', 
                    'RQM91', 'R1HKH', 'R0A07', 'RYJ01', 'RJ611', 'RJZ01')

# Clean and prepare each dataset separately
clean_data <- function(data, site_col) {
  data %>%
    mutate(
      IMD = if_else(is.na(IMD), "Unknown IMD", as.character(IMD)),
      Gender = if_else(is.na(Sex), "Unknown Gender", Sex),
      ethnic_group = if_else(
        is.na(ethnic_group) | ethnic_group == "Unknown",
        "Unknown Ethnicity",
        ethnic_group
      ),
      age_group = case_when(
        age < 25 ~ "16-24",
        age >= 25 & age < 35 ~ "25-34",
        age >= 35 & age < 50 ~ "35-49",
        age >= 50 & age < 65 ~ "50-64",
        age >= 65 & age < 80 ~ "65-79",
        age >= 80 ~ "80 and over",
        TRUE ~ NA_character_
      ),
      Site = as.character(!!sym(site_col))
      # Removed attendances_grouped
    ) %>%
    filter(
      IMD != "Unknown IMD",
      Gender != "Unknown Gender",
      ethnic_group != "Unknown Ethnicity",
      !is.na(age_group),
      !is.na(n_attendances)  # Filter based on continuous n_attendances
    ) %>%
    mutate(
      Gender = case_when(
        Gender == "MALE" ~ "Men",
        Gender == "FEMALE" ~ "Women",
        TRUE ~ Gender
      ),
      age_group = str_replace_all(age_group, "-", " to "),
      age_group = str_replace_all(age_group, "80\\+", "80 and over"),
      age_group = str_replace_all(age_group, "(\\d+)(to)(\\d+)", "\\1 to \\3")
    ) %>%
    filter(Site %in% included_sites)  # Filter to include only sentinel sites
}

# Load and clean data for HIV, HCV, and HBV attendees
attendees_HIV <- clean_data(load_attendees_data(Y006, "HIV"), "Site")
attendees_HCV <- clean_data(load_attendees_data(Y006, "HCV"), "SITE")
attendees_HBV <- clean_data(load_attendees_data(Y006, "HBV"), "Site")

```



```{r line-list-equity-of-uptake }

# Create separate line lists for HIV, HCV, and HBV
#getwd()

# HIV line list
hiv_line_list <- attendees_HIV %>%
  mutate(
    HIV_test = case_when(
      ECDS_bloods_any == "Yes" & HIV == "Yes" ~ 1,
      ECDS_bloods_any == "Yes" & (is.na(HIV) | HIV != "Yes") ~ 0,
      TRUE ~ NA_real_
    )
  ) %>%
  filter(!is.na(HIV_test)) %>%
  dplyr::select(
    TOKEN_PERSON_ID, HIV_test, 
    age_group, Gender, ethnic_group, IMD, Site, n_attendances
  )

# HCV line list
hcv_line_list <- attendees_HCV %>%
  mutate(
    HCV_test = case_when(
      ECDS_bloods_any == "Yes" & HCV == "Yes" ~ 1,
      ECDS_bloods_any == "Yes" & (is.na(HCV) | HCV != "Yes") ~ 0,
      TRUE ~ NA_real_
    )
  ) %>%
  filter(!is.na(HCV_test)) %>%
  dplyr::select(
    TOKEN_PERSON_ID, HCV_test, 
    age_group, Gender, ethnic_group, IMD, Site, n_attendances
  )

# HBV line list
hbv_line_list <- attendees_HBV %>%
  mutate(
    HBV_test = case_when(
      ECDS_bloods_any == "Yes" & HBV == "Yes" ~ 1,
      ECDS_bloods_any == "Yes" & (is.na(HBV) | HBV != "Yes") ~ 0,
      TRUE ~ NA_real_
    )
  ) %>%
  filter(!is.na(HBV_test)) %>%
  dplyr::select(
    TOKEN_PERSON_ID, HBV_test, 
    age_group, Gender, ethnic_group, IMD, Site, n_attendances
  )

# Display the first few rows of each line list
print("HIV Line List:")
print(head(hiv_line_list))
print("HCV Line List:")
print(head(hcv_line_list))
print("HBV Line List:")
print(head(hbv_line_list))

# Save the line lists to CSV files
write.csv(hiv_line_list, "hiv_test_uptake_line_list.csv", row.names = FALSE)
write.csv(hcv_line_list, "hcv_test_uptake_line_list.csv", row.names = FALSE)
write.csv(hbv_line_list, "hbv_test_uptake_line_list.csv", row.names = FALSE)


```



```{r logistic-regression-setup}
#Univariable Analysis
# Function to reorder factors and set reference levels
reorder_factors <- function(data) {
  data <- data %>%
    mutate(
      age_group = fct_relevel(as.factor(age_group), "35 to 49"),
      Gender = fct_relevel(as.factor(Gender), "Women"),
      ethnic_group = fct_relevel(as.factor(ethnic_group), "White British"),
      Site = fct_relevel(as.factor(Site), "RQM91"),
      IMD = fct_relevel(as.factor(IMD), "1"),
      n_attendances  = fct_relevel(as.factor(n_attendances), "1")
    )
  return(data)
}

# Define the reference groups
reference_groups_uni <- data.frame(
  term = c("age_group 35 to 49 (reference)",
           "Gender Women (reference)",
           "ethnic_group White British (reference)",
           "IMD 1 (reference)",
           "Site RQM91 (reference)",
           "n_attendances 1 (reference)")
)

# Function to calculate odds ratios from a contingency table
calculate_odds_ratio <- function(sub_table) {
  or <- (sub_table[1, 1] * sub_table[2, 2]) / (sub_table[1, 2] * sub_table[2, 1])
  return(or)
}

# Function to perform univariable logistic regression and calculate odds ratios
univariable_analysis <- function(df, outcome, reference_groups) {
  predictor_vars <- c("age_group", "Gender", "ethnic_group", "IMD", "Site", "n_attendances")
  
  results <- lapply(predictor_vars, function(var) {
    # Perform logistic regression
    formula <- as.formula(paste(outcome, "~", var))
    model <- glm(formula, data = df, family = binomial)
    
    # Extract coefficients and calculate odds ratios manually
    coef_summary <- summary(model)$coefficients
    odds_ratios <- exp(coef_summary[, "Estimate"])
    p_values <- coef_summary[, "Pr(>|z|)"]
    
    # Set odds ratio for reference group to 1
    odds_ratios[1] <- 1
    
    # Calculate chi-squared test
    chi_sq <- anova(model, test = "Chisq")
    chi_sq_value <- chi_sq[2, "Deviance"]
    p_value <- chi_sq[2, "Pr(>Chi)"]
    
    # Create a contingency table
    table <- table(df[[var]], df[[outcome]])
    
    # Calculate percentages for each subgroup
    percentages <- prop.table(table, margin = 1) * 100
    
    # Combine counts and percentages
    combined <- cbind(table, round(percentages, 1))
    colnames(combined) <- c("No", "Yes", "No_%", "Yes_%")
    
    # Extract the reference group
    reference <- reference_groups_uni$term[grepl(var, reference_groups_uni$term)]
    
    # Create a data frame with detailed results
    detailed_results <- data.frame(
      Variable = var,
      Subgroup = rownames(combined),
      No = combined[,"No"],
      Yes = combined[,"Yes"],
      No_Percent = combined[,"No_%"],
      Yes_Percent = combined[,"Yes_%"],
      Chi2 = chi_sq_value,
      p_value_univariable = p_value,
      Odds_Ratio = odds_ratios,
      Reference_Group = reference
    )
    
    # Filter out the intercept term
    detailed_results <- detailed_results %>%
      filter(Subgroup != "(Intercept)")
    
    return(detailed_results)
  })
  
  do.call(rbind, results)
}


#Multivariable Analysis
logistic_regression <- function(df, outcome) {
  model <- glm(as.formula(paste(outcome, "~ age_group + Gender + ethnic_group + IMD + Site + n_attendances")),
               data = df, family = binomial)
  
  coef_summary <- summary(model)$coefficients
  ci <- confint.default(model)
  
  tidy_model <- data.frame(
    term = rownames(coef_summary),
    OR = exp(coef_summary[, "Estimate"]),
    CI_lower = exp(ci[, 1]),
    CI_upper = exp(ci[, 2]),
    p.value_multivariable = coef_summary[, "Pr(>|z|)"]
  )
  
  # Filter out the intercept term
  tidy_model <- tidy_model %>%
    filter(term != "(Intercept)")
  
  return(tidy_model)
}



```



``` {r logistic-regression-HIV}
# Load the dataset

df_hiv <- read_csv("hiv_test_uptake_line_list.csv")  

# Ensure the largest group is the reference level for categorical variables
df_hiv <- reorder_factors(df_hiv)

# Perform univariable logistic regression analysis
uni_results_hiv <- univariable_analysis(df_hiv, "HIV_test", reference_groups_uni)

# Round all numeric columns to 3 decimal places
uni_results_hiv <- uni_results_hiv %>%
  mutate(across(where(is.numeric), round, 3)) # Increase precision values
  
#view(uni_results_hiv)

table_grob_hiv_univariable <- tableGrob(uni_results_hiv, rows = NULL)
ggsave("results_table_hiv_univariable.png", plot = table_grob_hiv_univariable, width = 15, height = 14)

# Perform multivariable logistic regression
logit_results_hiv <- logistic_regression(df_hiv, "HIV_test")

# Add reference groups for each subgroup
reference_groups <- data.frame(
  term = c("age group 35 to 49 (reference)", 
           "Gender Women (reference)", 
           "ethnic group White British (reference)", 
           "IMD quintile 1 (most deprived) (reference)", 
           "SiteRQM91 (reference)",
           "n_attendances 1 (reference)"),
  OR = NA, CI_lower = NA, CI_upper = NA, p.value_multivariable = NA
)

combined_results_hiv <- bind_rows(reference_groups, logit_results_hiv)

# Ensure unique factor levels
combined_results_hiv <- combined_results_hiv %>%
  mutate(term = make.unique(as.character(term)))

# Add reference groups only if they are not already present
combined_results_hiv <- bind_rows(reference_groups, combined_results_hiv) %>%
  distinct(term, .keep_all = TRUE)

# Round all numeric columns to 3 decimal places
combined_results_hiv <- combined_results_hiv %>%
  mutate(across(where(is.numeric), round, 3))

# Print and plot results for HIV
print("Results for HIV")
print(combined_results_hiv)

# Save the results table as a separate figure
table_grob_hiv <- tableGrob(combined_results_hiv, rows = NULL)
ggsave("results_table_hiv_multivariable.png", plot = table_grob_hiv, width = 10, height = 16)

# Adjust variable names for the forest plot
forest_plot_data <- combined_results_hiv %>%
  dplyr::filter(!str_detect(term, "^Site")) %>%
  dplyr::filter(!str_detect(term, "^n_attendances")) %>%
  dplyr::filter(!str_detect(term, "^Intercept|NA")) %>%
  mutate(term = case_when(
    term == "IMD1" ~ "IMD quintile 1 (most deprived)",
    term == "IMD2" ~ "IMD quintile 2",
    term == "IMD3" ~ "IMD quintile 3",
    term == "IMD4" ~ "IMD quintile 4",
    term == "IMD5" ~ "IMD quintile 5 (least deprived)",
    term == "GenderWomen" ~ "Gender Women (reference)",
    term == "GenderMen" ~ "Gender Men",
    term == "ethnic_groupWhite British" ~ "ethnic group White British (reference)",
    term == "ethnic_groupWhite Other" ~ "ethnic group White Other",
    term == "ethnic_groupMixed/Multiple" ~ "ethnic group Mixed/Multiple",
    term == "ethnic_groupAsian Other" ~ "ethnic group Asian Other",
    term == "ethnic_groupBlack African" ~ "ethnic group Black African",
    term == "ethnic_groupBlack Caribbean" ~ "ethnic group Black Caribbean",
    term == "ethnic_groupBlack Other" ~ "ethnic group Black Other",
    term == "ethnic_groupIndian, Pakistani or Bangladeshi" ~ "ethnic group Indian, Pakistani or Bangladeshi",
    term == "ethnic_groupOther" ~ "ethnic group Other",
    term == "age_group16 to 24" ~ "age group 16 to 24",
    term == "age_group25 to 34" ~ "age group 25 to 34",
    term == "age_group35 to 49" ~ "age group 35 to 49 (reference)",
    term == "age_group50 to 64" ~ "age group 50 to 64",
    term == "age_group65 to 79" ~ "age group 65 to 79",
    term == "age_group80 and over" ~ "age group 80 and over",
    TRUE ~ term
  ))


# Create the forest plot with the adjusted variable names and order
forest_plot_hiv <- ggplot(forest_plot_data, aes(x = OR, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = CI_lower, xmax = CI_upper)) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  xlab("Odds Ratio") +
  ylab("Predictor Variables") +
  ggtitle("Forest Plot of HIV Logistic Regression Results") +
  theme_pubr() +
  theme(axis.text.y = element_text(hjust = 1, size = 10))

# Save the forest plot
ggsave("forest_plot_hiv.png", plot = forest_plot_hiv, width = 10, height = 8)

# Display the forest plot
print(forest_plot_hiv)

print("Results table and forest plot have been saved as separate figures.")


```


```{r multilevel-logistic-regression-HIV}

# Load the dataset
df_hiv <- read_csv("hiv_test_uptake_line_list.csv")

# Ensure 'Site' is a factor
df_hiv$Site <- as.factor(df_hiv$Site)

# Convert n_attendances to numeric if it's a factor
df_hiv$n_attendances <- as.numeric(as.character(df_hiv$n_attendances))

# Ensure HIV_test is a numeric binary variable
df_hiv$HIV_test <- as.numeric(as.character(df_hiv$HIV_test))

# Recode n_attendances into categories
df_hiv <- df_hiv %>%
  mutate(
    n_attendances_cat = case_when(
      n_attendances == 1 ~ "1",
      n_attendances == 2 ~ "2",
      n_attendances >= 3 & n_attendances <= 5 ~ "3-5",
      n_attendances >= 6 & n_attendances <= 10 ~ "6-10",
      n_attendances >= 11 ~ "11+"
    )
  )

# Convert to factor and set reference level
df_hiv$n_attendances_cat <- factor(df_hiv$n_attendances_cat, levels = c("1", "2", "3-5", "6-10", "11+"))

table(df_hiv$n_attendances_cat)

# Reorder factors and set reference levels
df_hiv <- df_hiv %>%
  mutate(
    age_group = fct_relevel(as.factor(age_group), "35 to 49"),
    Gender = fct_relevel(as.factor(Gender), "Women"),
    ethnic_group = fct_relevel(as.factor(ethnic_group), "White British"),
    IMD = fct_relevel(as.factor(IMD), "1"),
    n_attendances_cat = fct_relevel(as.factor(n_attendances_cat), "1")
  )

# Fit a mixed-effects logistic regression model with random intercepts for Site
mixed_model <- glmer(
  HIV_test ~ age_group + Gender + ethnic_group + IMD + n_attendances_cat + (1 | Site),
  data = df_hiv,
  family = binomial,
  nAGQ = 0
)

# Summarize the model
summary(mixed_model)

# Extract fixed effects with confidence intervals
tidy_mixed_model <- broom.mixed::tidy(
  mixed_model,
  conf.int = TRUE,
  conf.method = "Wald",
  effects = "fixed"
)

# Exponentiate coefficients to get odds ratios
tidy_mixed_model <- tidy_mixed_model %>%
  mutate(
    OR = exp(estimate),
    OR_lower = exp(conf.low),
    OR_upper = exp(conf.high)
  )

# Display the fixed effects with odds ratios
print("Fixed Effects with Odds Ratios:")
print(tidy_mixed_model)

# Save fixed effects to CSV
write.csv(tidy_mixed_model, "fixed_effects.csv", row.names = FALSE)



# Extract and display the random effects for Site
site_random_effects <- ranef(mixed_model)$Site
print("Random Effects for Site:")
print(site_random_effects)

# Save random effects to CSV
write.csv(site_random_effects, "random_effects.csv", row.names = FALSE)


# Calculate the Intraclass Correlation Coefficient (ICC)
variance_components <- as.data.frame(VarCorr(mixed_model))
site_variance <- variance_components$vcov[variance_components$grp == "Site"]
residual_variance <- (pi^2) / 3  # Approximate residual variance for logistic models
ICC <- site_variance / (site_variance + residual_variance)
print(paste("Intraclass Correlation Coefficient (ICC):", round(ICC, 3)))

# Create a forest plot of fixed effects
forest_plot_mixed_model <- ggplot(
  tidy_mixed_model %>% 
    filter(term != "(Intercept)" & !str_detect(term, "^n_attendances_cat")),  # Modified filter
  aes(x = OR, y = term)
) +
  geom_point() +
  geom_errorbarh(aes(xmin = OR_lower, xmax = OR_upper), height = 0.2) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  xlab("Odds Ratio") +
  ylab("Predictor Variables") +
  ggtitle("Forest Plot of Fixed Effects Results") +
  theme_pubr() +
  theme(axis.text.y = element_text(hjust = 1, size = 10))

# Save the forest plot
ggsave("forest_plot_mixed_model.png", plot = forest_plot_mixed_model, width = 10, height = 8)

# Display the forest plot
print(forest_plot_mixed_model)

# Plot random effects for Site
dotplot(ranef(mixed_model, condVar = TRUE), main = "Random Effects for Site")

# Save the random effects plot
ggsave("random_effects_site.png", width = 10, height = 6)


-----
#Gender  
# Fit a mixed-effects logistic regression model with random intercepts and slopes for Gender
mixed_model_improved <- glmer(
  HIV_test ~ age_group + Gender + ethnic_group + IMD + n_attendances_cat + 
    (1 + Gender | Site),
  data = df_hiv,
  family = binomial,
  nAGQ = 0,  # Use Laplace approximation for faster computation
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
)

# Summarize the model
summary(mixed_model_improved)

# Extract fixed effects with confidence intervals
tidy_mixed_model_improved <- broom.mixed::tidy(
  mixed_model_improved,
  conf.int = TRUE,
  conf.method = "Wald",
  effects = "fixed"
)

# Exponentiate coefficients to get odds ratios
tidy_mixed_model_improved <- tidy_mixed_model_improved %>%
  mutate(
    OR = exp(estimate),
    OR_lower = exp(conf.low),
    OR_upper = exp(conf.high)
  )

# Display the fixed effects with odds ratios
print("Fixed Effects with Odds Ratios:")
print(tidy_mixed_model_improved)

# Extract and display the random effects for Site
site_random_effects_improved <- ranef(mixed_model_improved, condVar = TRUE)$Site
print("Random Effects for Site (Intercept and Gender Slopes):")
print(site_random_effects_improved)

# Calculate the Intraclass Correlation Coefficient (ICC) for the intercept
variance_components <- as.data.frame(VarCorr(mixed_model_improved))
site_variance_intercept <- variance_components$vcov[variance_components$grp == "Site" & variance_components$var1 == "(Intercept)"]
residual_variance <- (pi^2) / 3  # Approximate residual variance for logistic models
ICC_intercept <- site_variance_intercept / (site_variance_intercept + residual_variance)
print(paste("Intraclass Correlation Coefficient (ICC) for Intercept:", round(ICC_intercept, 3)))


----
#Age group
# Fit the mixed-effects logistic regression model with random slopes for age group
# Create a categorical variable for each age group level for random effects
df_hiv <- df_hiv %>%
  mutate(
    age_16_24 = as.numeric(age_group == "16 to 24"),
    age_25_34 = as.numeric(age_group == "25 to 34"),
    age_50_64 = as.numeric(age_group == "50 to 64"),
    age_65_79 = as.numeric(age_group == "65 to 79"),
    age_80plus = as.numeric(age_group == "80 and over")
    # Note: 35-49 is reference category
  )

# Fit model with individual random slopes for each age group
mixed_model_age_detailed <- glmer(
  HIV_test ~ age_group + Gender + ethnic_group + IMD + n_attendances_cat + 
    (1 + age_16_24 + age_25_34 + age_50_64 + age_65_79 + age_80plus || Site),
  data = df_hiv,
  family = binomial,
  nAGQ = 0,
  control = glmerControl(
    optimizer = "bobyqa",
    optCtrl = list(maxfun = 1e5),
    calc.derivs = FALSE
  )
)

# Extract random effects for sites
site_random_effects <- ranef(mixed_model_age_detailed)$Site

# Convert random effects to interpretable format
site_variations_age <- data.frame(
  Site = rownames(site_random_effects),
  Intercept = site_random_effects[,1],
  Effect_16_24 = site_random_effects[,2],
  Effect_25_34 = site_random_effects[,3],
  Effect_50_64 = site_random_effects[,4],
  Effect_65_79 = site_random_effects[,5],
  Effect_80plus = site_random_effects[,6]
)

# Display site-specific variations
print("Site-specific variations in age group effects (relative to 35-49):")
print(site_variations_age)

# Get fixed effects with confidence intervals
tidy_mixed_model_age <- broom.mixed::tidy(
  mixed_model_age_detailed,
  conf.int = TRUE,
  conf.method = "Wald",
  effects = "fixed"
) %>%
  mutate(
    OR = exp(estimate),
    OR_lower = exp(conf.low),
    OR_upper = exp(conf.high)
  )

print("Fixed Effects with Odds Ratios:")
print(tidy_mixed_model_age)

# Calculate ICC for the intercept
variance_components <- as.data.frame(VarCorr(mixed_model_ethnic))
site_variance_intercept <- variance_components$vcov[variance_components$grp == "Site" & 
                                                  variance_components$var1 == "(Intercept)"]
residual_variance <- (pi^2) / 3
ICC_intercept <- site_variance_intercept / (site_variance_intercept + residual_variance)
print(paste("Intraclass Correlation Coefficient (ICC) for Intercept:", 
            round(ICC_intercept, 3)))



---

#IMD
#Since IMD is ordinal, we can also convert it to a numeric variable
# Convert IMD to numeric
df_hiv <- df_hiv %>%
  mutate(
    imd_2 = as.numeric(IMD == "2"),
    imd_3 = as.numeric(IMD == "3"),
    imd_4 = as.numeric(IMD == "4"),
    imd_5 = as.numeric(IMD == "5")
  )

# Fit model with individual random slopes for each IMD level
mixed_model_IMD <- glmer(
  HIV_test ~ IMD + Gender + age_group + ethnic_group + n_attendances_cat + 
    (1 + imd_2 + imd_3 + imd_4 + imd_5 || Site),
  data = df_hiv,
  family = binomial,
  nAGQ = 0,
  control = glmerControl(
    optimizer = "bobyqa",
    optCtrl = list(maxfun = 1e5),
    calc.derivs = FALSE
  )
)
# Summarize the model
summary(mixed_model_IMD)

# Extract fixed effects with confidence intervals
tidy_mixed_model_IMD <- broom.mixed::tidy(
  mixed_model_IMD,
  conf.int = TRUE,
  conf.method = "Wald",
  effects = "fixed"
)

# Exponentiate coefficients to get odds ratios
tidy_mixed_model_IMD <- tidy_mixed_model_IMD %>%
  mutate(
    OR = exp(estimate),
    OR_lower = exp(conf.low),
    OR_upper = exp(conf.high)
  )

# Display the fixed effects with odds ratios
print("Fixed Effects with Odds Ratios for IMD:")
print(tidy_mixed_model_IMD)

# Extract and display the random effects for Site
site_random_effects_IMD <- ranef(mixed_model_IMD, condVar = TRUE)$Site
print("Random Effects for Site (Intercept and IMD Slopes):")
print(site_random_effects_IMD)


# Calculate the ICC for the intercept
variance_components_IMD <- as.data.frame(VarCorr(mixed_model_IMD))
site_variance_intercept_IMD <- variance_components_IMD$vcov[variance_components_IMD$grp == "Site" & variance_components_IMD$var1 == "(Intercept)"]
ICC_intercept_IMD <- site_variance_intercept_IMD / (site_variance_intercept_IMD + residual_variance)
print(paste("Intraclass Correlation Coefficient (ICC) for Intercept (IMD):", round(ICC_intercept_IMD, 3)))

---

#Ethnic Group
# Create binary indicators for each ethnic group (White British as reference)
df_hiv <- df_hiv %>%
  mutate(
    eth_white_other = as.numeric(ethnic_group == "White Other"),
    eth_mixed = as.numeric(ethnic_group == "Mixed/Multiple"),
    eth_asian_other = as.numeric(ethnic_group == "Asian Other"),
    eth_black_african = as.numeric(ethnic_group == "Black African"),
    eth_black_caribbean = as.numeric(ethnic_group == "Black Caribbean"),
    eth_black_other = as.numeric(ethnic_group == "Black Other"),
    eth_ipb = as.numeric(ethnic_group == "Indian, Pakistani or Bangladeshi"),
    eth_other = as.numeric(ethnic_group == "Other")
    # Note: White British is reference category
  )

# Fit model with individual random slopes for each ethnic group
mixed_model_ethnic <- glmer(
  HIV_test ~ ethnic_group + Gender + age_group + IMD + n_attendances_cat + 
    (1 + eth_white_other + eth_mixed + eth_asian_other + 
     eth_black_african + eth_black_caribbean + eth_black_other + 
     eth_ipb + eth_other || Site),
  data = df_hiv,
  family = binomial,
  nAGQ = 0,
  control = glmerControl(
    optimizer = "bobyqa",
    optCtrl = list(maxfun = 1e5),
    calc.derivs = FALSE
  )
)

# Extract and format random effects for sites
site_random_effects <- ranef(mixed_model_ethnic)$Site

# Convert random effects to interpretable format
site_variations <- data.frame(
  Site = rownames(site_random_effects),
  Intercept = site_random_effects[,1],
  Effect_White_Other = site_random_effects[,2],
  Effect_Mixed = site_random_effects[,3],
  Effect_Asian_Other = site_random_effects[,4],
  Effect_Black_African = site_random_effects[,5],
  Effect_Black_Caribbean = site_random_effects[,6],
  Effect_Black_Other = site_random_effects[,7],
  Effect_IPB = site_random_effects[,8],
  Effect_Other = site_random_effects[,9]
)

# Display site-specific variations
print("Site-specific variations in ethnic group effects (relative to White British):")
print(site_variations)

# Get fixed effects with confidence intervals
tidy_mixed_model_ethnic <- broom.mixed::tidy(
  mixed_model_ethnic,
  conf.int = TRUE,
  conf.method = "Wald",
  effects = "fixed"
) %>%
  mutate(
    OR = exp(estimate),
    OR_lower = exp(conf.low),
    OR_upper = exp(conf.high)
  )

print("Fixed Effects with Odds Ratios:")
print(tidy_mixed_model_ethnic)

# Calculate ICC for the intercept
variance_components <- as.data.frame(VarCorr(mixed_model_ethnic))
site_variance_intercept <- variance_components$vcov[variance_components$grp == "Site" & 
                                                  variance_components$var1 == "(Intercept)"]
residual_variance <- (pi^2) / 3
ICC_intercept <- site_variance_intercept / (site_variance_intercept + residual_variance)
print(paste("Intraclass Correlation Coefficient (ICC) for Intercept:", 
            round(ICC_intercept, 3)))
  
```



```{r logistic-regression-HCV}

# Load the dataset
df_hcv <- read_csv("hcv_test_uptake_line_list.csv")

# Ensure the largest group is the reference level for categorical variables
df_hcv <- reorder_factors(df_hcv)

# Perform univariable logistic regression analysis
uni_results_hcv <- univariable_analysis(df_hcv, "HCV_test", reference_groups_uni)

uni_results_hcv <- uni_results_hcv %>%
  mutate(across(where(is.numeric), round, 3)) # Increase precision values
  
#view(uni_results_hcv)

table_grob_hcv_univariable <- tableGrob(uni_results_hcv, rows = NULL)
ggsave("results_table_hcv_univariable.png", plot = table_grob_hcv_univariable, width = 15, height = 14)

# Perform logistic regression
logit_results_hcv <- logistic_regression(df_hcv, "HCV_test")

# Add reference groups for each subgroup
reference_groups <- data.frame(
  term = c("age group 35 to 49 (reference)", 
           "Gender Women (reference)", 
           "ethnic group White British (reference)", 
           "IMD quintile 1 (most deprived) (reference)", 
           "SiteRQM91 (reference)",
           "n_attendances 1 (reference)"),
  OR = NA, CI_lower = NA, CI_upper = NA, p.value_multivariable = NA
)

combined_results_hcv <- bind_rows(reference_groups, logit_results_hcv)

# Ensure unique factor levels
combined_results_hcv <- combined_results_hcv %>%
  mutate(term = make.unique(as.character(term)))

# Add reference groups only if they are not already present
combined_results_hcv <- bind_rows(reference_groups, combined_results_hcv) %>%
  distinct(term, .keep_all = TRUE)

# Round all numeric columns to 3 decimal places
combined_results_hcv <- combined_results_hcv %>%
  mutate(across(where(is.numeric), round, 3))

#view(combined_results_hcv)

# Print and plot results for HCV
print("Results for HCV")
print(combined_results_hcv)

# Save the results table as a separate figure
table_grob_hcv <- tableGrob(combined_results_hcv, rows = NULL)
ggsave("results_table_hcv_multivariable.png", plot = table_grob_hcv, width = 10, height = 16)

# Adjust variable names for the forest plot
forest_plot_data <- combined_results_hcv %>%
  dplyr::filter(!str_detect(term, "^Site")) %>%
  dplyr::filter(!str_detect(term, "^n_attendances")) %>%
  dplyr::filter(!str_detect(term, "^Intercept|NA")) %>%
  mutate(term = case_when(
    term == "IMD1" ~ "IMD quintile 1 (most deprived)",
    term == "IMD2" ~ "IMD quintile 2",
    term == "IMD3" ~ "IMD quintile 3",
    term == "IMD4" ~ "IMD quintile 4",
    term == "IMD5" ~ "IMD quintile 5 (least deprived)",
    term == "GenderWomen" ~ "Gender Women (reference)",
    term == "GenderMen" ~ "Gender Men",
    term == "ethnic_groupWhite British" ~ "ethnic group White British (reference)",
    term == "ethnic_groupWhite Other" ~ "ethnic group White Other",
    term == "ethnic_groupMixed/Multiple" ~ "ethnic group Mixed/Multiple",
    term == "ethnic_groupAsian Other" ~ "ethnic group Asian Other",
    term == "ethnic_groupBlack African" ~ "ethnic group Black African",
    term == "ethnic_groupBlack Caribbean" ~ "ethnic group Black Caribbean",
    term == "ethnic_groupBlack Other" ~ "ethnic group Black Other",
    term == "ethnic_groupIndian, Pakistani or Bangladeshi" ~ "ethnic group Indian, Pakistani or Bangladeshi",
    term == "ethnic_groupOther" ~ "ethnic group Other",
    term == "age_group16 to 24" ~ "age group 16 to 24",
    term == "age_group25 to 34" ~ "age group 25 to 34",
    term == "age_group35 to 49" ~ "age group 35 to 49 (reference)",
    term == "age_group50 to 64" ~ "age group 50 to 64",
    term == "age_group65 to 79" ~ "age group 65 to 79",
    term == "age_group80 and over" ~ "age group 80 and over",
    TRUE ~ term
  ))

# Create the forest plot with the adjusted variable names and order
forest_plot_hcv <- ggplot(forest_plot_data, aes(x = OR, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = CI_lower, xmax = CI_upper)) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  xlab("Odds Ratio") +
  ylab("Predictor Variables") +
  ggtitle("Forest Plot of HCV Logistic Regression Results") +
  theme_pubr() +
  theme(axis.text.y = element_text(hjust = 1, size = 10))

# Save the forest plot
ggsave("forest_plot_hcv.png", plot = forest_plot_hcv, width = 10, height = 8)

# Display the forest plot
print(forest_plot_hcv)

print("Results table and forest plot have been saved as separate figures.")

```



```{r logistic-regression-HBV}

# Load the dataset
df_hbv <- read_csv("hbv_test_uptake_line_list.csv")

# Ensure the largest group is the reference level for categorical variables
df_hbv <- reorder_factors(df_hbv)

# Perform univariable logistic regression analysis
uni_results_hbv <- univariable_analysis(df_hbv, "HBV_test", reference_groups_uni)

uni_results_hbv <- uni_results_hbv %>%
  mutate(across(where(is.numeric), round, 3)) # Increase precision values
  
#view(uni_results_hbv)

table_grob_hbv_univariable <- tableGrob(uni_results_hbv, rows = NULL)
ggsave("results_table_hbv_univariable.png", plot = table_grob_hbv_univariable, width = 15, height = 14)

# Perform logistic regression
logit_results_hbv <- logistic_regression(df_hbv, "HBV_test")

# Add reference groups for each subgroup
reference_groups <- data.frame(
  term = c("age group 35 to 49 (reference)", 
           "Gender Women (reference)", 
           "ethnic group White British (reference)", 
           "IMD quintile 1 (most deprived) (reference)", 
           "SiteRQM91 (reference)",
           "n_attendances 1 (reference)"),
  OR = NA, CI_lower = NA, CI_upper = NA, p.value_multivariable = NA
)

combined_results_hbv <- bind_rows(reference_groups, logit_results_hbv)

# Ensure unique factor levels
combined_results_hbv <- combined_results_hbv %>%
  mutate(term = make.unique(as.character(term)))

# Add reference groups only if they are not already present
combined_results_hbv <- bind_rows(reference_groups, combined_results_hbv) %>%
  distinct(term, .keep_all = TRUE)

# Convert CI_lower and CI_upper to numeric to ensure rounding works
combined_results_hbv <- combined_results_hbv %>%
  mutate(
    CI_lower = as.numeric(CI_lower),
    CI_upper = as.numeric(CI_upper)
  )

# Round all numeric columns to 3 decimal places
combined_results_hbv <- combined_results_hbv %>%
  mutate(across(where(is.numeric) & !matches("CI_upper"), round, 3),
         CI_upper = round(CI_upper, 3) # Increase precision for CI_upper
  )


#view(combined_results_hbv)

# Print and plot results for HBV
print("Results for HBV")
print(combined_results_hbv)

# Save the results table as a separate figure
table_grob_hbv <- tableGrob(combined_results_hbv, rows = NULL)
ggsave("results_table_hbv_multivariable.png", plot = table_grob_hbv, width = 10, height = 16)

# Adjust variable names for the forest plot
forest_plot_data <- combined_results_hbv %>%
  dplyr::filter(!str_detect(term, "^Site")) %>%
  dplyr::filter(!str_detect(term, "^n_attendances")) %>%
  dplyr::filter(!str_detect(term, "^Intercept|NA")) %>%
  mutate(term = case_when(
    term == "IMD1" ~ "IMD quintile 1 (most deprived)",
    term == "IMD2" ~ "IMD quintile 2",
    term == "IMD3" ~ "IMD quintile 3",
    term == "IMD4" ~ "IMD quintile 4",
    term == "IMD5" ~ "IMD quintile 5 (least deprived)",
    term == "GenderWomen" ~ "Gender Women (reference)",
    term == "GenderMen" ~ "Gender Men",
    term == "ethnic_groupWhite British" ~ "ethnic group White British (reference)",
    term == "ethnic_groupWhite Other" ~ "ethnic group White Other",
    term == "ethnic_groupMixed/Multiple" ~ "ethnic group Mixed/Multiple",
    term == "ethnic_groupAsian Other" ~ "ethnic group Asian Other",
    term == "ethnic_groupBlack African" ~ "ethnic group Black African",
    term == "ethnic_groupBlack Caribbean" ~ "ethnic group Black Caribbean",
    term == "ethnic_groupBlack Other" ~ "ethnic group Black Other",
    term == "ethnic_groupIndian, Pakistani or Bangladeshi" ~ "ethnic group Indian, Pakistani or Bangladeshi",
    term == "ethnic_groupOther" ~ "ethnic group Other",
    term == "age_group16 to 24" ~ "age group 16 to 24",
    term == "age_group25 to 34" ~ "age group 25 to 34",
    term == "age_group35 to 49" ~ "age group 35 to 49 (reference)",
    term == "age_group50 to 64" ~ "age group 50 to 64",
    term == "age_group65 to 79" ~ "age group 65 to 79",
    term == "age_group80 and over" ~ "age group 80 and over",
    TRUE ~ term
  ))

# Create the forest plot with the adjusted variable names and order
forest_plot_hbv <- ggplot(forest_plot_data, aes(x = OR, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = CI_lower, xmax = CI_upper)) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  xlab("Odds Ratio") +
  ylab("Predictor Variables") +
  ggtitle("Forest Plot of HBV Logistic Regression Results") +
  theme_pubr() +
  theme(axis.text.y = element_text(hjust = 1, size = 10))

# Save the forest plot
ggsave("forest_plot_hbv.png", plot = forest_plot_hbv, width = 10, height = 8)

# Display the forest plot
print(forest_plot_hbv)

print("Results table and forest plot have been saved as separate figures.")

```



```{r Nested-analysis-attendance-comparison}

# Load the HIV dataset
df_hiv <- read_csv("hiv_test_uptake_line_list.csv")

# Fit the model without attendances_grouped
model_without_attendances <- glm(HIV_test ~ age_group + Gender + ethnic_group + IMD + Site, 
                                 data = df_hiv, family = binomial)

# Fit the model with attendances_grouped
model_with_attendances <- glm(HIV_test ~ age_group + Gender + ethnic_group + IMD + Site + attendances_grouped, 
                              data = df_hiv, family = binomial)

# Conduct Likelihood Ratio Test
lrt_result <- anova(model_without_attendances, model_with_attendances, test = "LRT")

# Output the LRT results
print("Likelihood Ratio Test results:")
print(lrt_result)

# Compare AIC of the models
aic_comparison <- data.frame(
  Model = c("Without attendances_grouped", "With attendances_grouped"),
  AIC = c(AIC(model_without_attendances), AIC(model_with_attendances))
)

print("\nAIC Comparison:")
print(aic_comparison)

# Calculate McFadden's R-squared for each model
mcfadden_r2 <- function(model) {
  1 - (model$deviance / model$null.deviance)
}

r2_comparison <- data.frame(
  Model = c("Without attendances_grouped", "With attendances_grouped"),
  McFadden_R2 = c(mcfadden_r2(model_without_attendances), mcfadden_r2(model_with_attendances))
)

print("\nMcFadden's R-squared Comparison:")
print(r2_comparison)

# Calculate and compare the number of parameters in each model
params_comparison <- data.frame(
  Model = c("Without attendances_grouped", "With attendances_grouped"),
  Number_of_Parameters = c(length(coef(model_without_attendances)), length(coef(model_with_attendances)))
)

print("\nNumber of Parameters Comparison:")
print(params_comparison)

# Perform 10-fold cross-validation for both models
set.seed(123)  # for reproducibility
cv_folds <- createFolds(df_hiv$HIV_test, k = 10)

cv_results <- lapply(cv_folds, function(test_indices) {
  train_data <- df_hiv[-test_indices, ]
  test_data <- df_hiv[test_indices, ]
  
  # Train and test model without attendances_grouped
  model_without_att_cv <- glm(HIV_test ~ age_group + Gender + ethnic_group + IMD + Site, 
                              data = train_data, family = binomial)
  without_att_pred <- predict(model_without_att_cv, newdata = test_data, type = "response")
  without_att_auc <- auc(test_data$HIV_test, without_att_pred)
  
  # Train and test model with attendances_grouped
  model_with_att_cv <- glm(HIV_test ~ age_group + Gender + ethnic_group + IMD + Site + attendances_grouped, 
                           data = train_data, family = binomial)
  with_att_pred <- predict(model_with_att_cv, newdata = test_data, type = "response")
  with_att_auc <- auc(test_data$HIV_test, with_att_pred)
  
  return(c(without_att_auc, with_att_auc))
})

cv_results_df <- data.frame(do.call(rbind, cv_results))
colnames(cv_results_df) <- c("Without attendances_grouped", "With attendances_grouped")

print("\nCross-validation Results (AUC):")
print(cv_results_df)

print("\nMean AUC:")
print(colMeans(cv_results_df))

```



```{r Stratified-Nested-analysis-auto-v-non-auto-with-sites}

# Load the HIV dataset
df_hcv <- read_csv("hcv_test_uptake_line_list.csv")

# List of automated sites
automated_sites <- c('RJ122', 'RYJ02', 'R0A02', 'R0A66', 'RJ231', 
                     'RJ224', 'RQM91', 'R0A07', 'RYJ01')

# Create a new variable to indicate if a site is automated
df_hcv <- df_hcv %>%
  mutate(is_automated = ifelse(Site %in% automated_sites, "Automated", "Non-automated"))

# Stratify the data
df_automated <- df_hcv %>% filter(is_automated == "Automated")
df_non_automated <- df_hcv %>% filter(is_automated == "Non-automated")

# Fit models within each stratum, including Site as a predictor
model_automated <- glm(HCV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped + Site, 
                       data = df_automated, family = binomial)

model_non_automated <- glm(HCV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped + Site, 
                           data = df_non_automated, family = binomial)

# Output model summaries
print("Model Summary for Automated Sites:")
summary(model_automated)

print("\nModel Summary for Non-Automated Sites:")
summary(model_non_automated)

# Perform 10-fold cross-validation for stratified models
set.seed(123)  # for reproducibility
cv_folds_auto <- createFolds(df_automated$HCV_test, k = 10)
cv_folds_non_auto <- createFolds(df_non_automated$HCV_test, k = 10)

cv_results_auto <- lapply(cv_folds_auto, function(test_indices) {
  train_data <- df_automated[-test_indices, ]
  test_data <- df_automated[test_indices, ]
  
  # Train and test model for automated sites
  model_auto_cv <- glm(HCV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped + Site, 
                       data = train_data, family = binomial)
  auto_pred <- predict(model_auto_cv, newdata = test_data, type = "response")
  auto_auc <- auc(test_data$HCV_test, auto_pred)
  
  return(auto_auc)
})

cv_results_non_auto <- lapply(cv_folds_non_auto, function(test_indices) {
  train_data <- df_non_automated[-test_indices, ]
  test_data <- df_non_automated[test_indices, ]
  
  # Train and test model for non-automated sites
  model_non_auto_cv <- glm(HCV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped + Site, 
                           data = train_data, family = binomial)
  non_auto_pred <- predict(model_non_auto_cv, newdata = test_data, type = "response")
  non_auto_auc <- auc(test_data$HCV_test, non_auto_pred)
  
  return(non_auto_auc)
})

cv_results_df_auto <- data.frame(AUC_Automated = unlist(cv_results_auto))
cv_results_df_non_auto <- data.frame(AUC_Non_Automated = unlist(cv_results_non_auto))

print("\nCross-validation Results (AUC) for Automated Sites:")
print(cv_results_df_auto)

print("\nCross-validation Results (AUC) for Non-Automated Sites:")
print(cv_results_df_non_auto)

print("\nMean AUC for Automated Sites:")
print(mean(cv_results_df_auto$AUC_Automated))

print("\nMean AUC for Non-Automated Sites:")
print(mean(cv_results_df_non_auto$AUC_Non_Automated))

```



```{r forest-plot-auto-v-nonauto-model-compare-HIV}

# Load the dataset
df_hbv <- read_csv("hbv_test_uptake_line_list.csv")

# List of automated sites
automated_sites <- c('RJ122', 'RYJ02', 'R0A02', 'R0A66', 'RJ231', 'RJ224', 'RQM91', 'R0A07', 'RYJ01')

# Filter for Automated Sites
df_automated <- df_hbv %>% 
  filter(Site %in% automated_sites)

# Reorder factors and set reference levels
df_automated <- reorder_factors(df_automated)

# Perform univariable logistic regression analysis
uni_results_auto <- univariable_analysis(df_automated, "HBV_test", reference_groups_uni)

# Perform multivariable logistic regression analysis
logit_results_auto <- logistic_regression(df_automated, "HBV_test")

# Add reference groups
combined_results_auto <- bind_rows(reference_groups, logit_results_auto)

# Adjust variable names for forest plot
forest_plot_data_auto <- combined_results_auto %>%
  dplyr::filter(!str_detect(term, "^Site")) %>%
  dplyr::filter(!str_detect(term, "^attendances_grouped")) %>%
  dplyr::filter(!str_detect(term, "^Intercept|NA")) %>%
 mutate(term = case_when(
    term == "IMD1" ~ "IMD quintile 1 (most deprived)",
    term == "IMD2" ~ "IMD quintile 2",
    term == "IMD3" ~ "IMD quintile 3",
    term == "IMD4" ~ "IMD quintile 4",
    term == "IMD5" ~ "IMD quintile 5 (least deprived)",
    term == "GenderWomen" ~ "Gender Women (reference)",
    term == "GenderMen" ~ "Gender Men",
    term == "ethnic_groupWhite British" ~ "ethnic group White British (reference)",
    term == "ethnic_groupWhite Other" ~ "ethnic group White Other",
    term == "ethnic_groupMixed/Multiple" ~ "ethnic group Mixed/Multiple",
    term == "ethnic_groupAsian Other" ~ "ethnic group Asian Other",
    term == "ethnic_groupBlack African" ~ "ethnic group Black African",
    term == "ethnic_groupBlack Caribbean" ~ "ethnic group Black Caribbean",
    term == "ethnic_groupBlack Other" ~ "ethnic group Black Other",
    term == "ethnic_groupIndian, Pakistani or Bangladeshi" ~ "ethnic group Indian, Pakistani or Bangladeshi",
    term == "ethnic_groupOther" ~ "ethnic group Other",
    term == "age_group16 to 24" ~ "age group 16 to 24",
    term == "age_group25 to 34" ~ "age group 25 to 34",
    term == "age_group35 to 49" ~ "age group 35 to 49 (reference)",
    term == "age_group50 to 64" ~ "age group 50 to 64",
    term == "age_group65 to 79" ~ "age group 65 to 79",
    term == "age_group80 and over" ~ "age group 80 and over",
    TRUE ~ term
  ))

# Create forest plot for Automated Sites
forest_plot_auto <- ggplot(forest_plot_data_auto, aes(x = OR, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = CI_lower, xmax = CI_upper)) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  xlab("Odds Ratio") +
  ylab("Predictor Variables") +
  ggtitle("Forest Plot of HBV Logistic Regression Results (Automated Sites)") +
  theme_pubr() +
  theme(axis.text.y = element_text(hjust = 1, size = 10))

# Save and display the forest plot
ggsave("forest_plot_auto_hbv.png", plot = forest_plot_auto, width = 10, height = 8)
print(forest_plot_auto)

---
  
# Load the dataset
df_hbv <- read_csv("hbv_test_uptake_line_list.csv")

# List of automated sites
automated_sites <- c('RJ122', 'RYJ02', 'R0A02', 'R0A66', 'RJ231', 'RJ224', 'RQM91', 'R0A07', 'RYJ01')

# Filter for Non-Automated Sites
df_non_automated <- df_hbv %>%
  filter(!Site %in% automated_sites)

# Reorder factors and set reference levels
df_non_automated <- reorder_factors(df_non_automated)

# Perform univariable logistic regression analysis
uni_results_non_auto <- univariable_analysis(df_non_automated, "HBV_test", reference_groups_uni)

# Perform multivariable logistic regression analysis
logit_results_non_auto <- logistic_regression(df_non_automated, "HBV_test")

# Add reference groups
combined_results_non_auto <- bind_rows(reference_groups, logit_results_non_auto)

# Adjust variable names for forest plot
forest_plot_data_non_auto <- combined_results_non_auto %>%
  dplyr::filter(!str_detect(term, "^Site")) %>%
  dplyr::filter(!str_detect(term, "^attendances_grouped")) %>%
  dplyr::filter(!str_detect(term, "^Intercept|NA")) %>%
 mutate(term = case_when(
    term == "IMD1" ~ "IMD quintile 1 (most deprived)",
    term == "IMD2" ~ "IMD quintile 2",
    term == "IMD3" ~ "IMD quintile 3",
    term == "IMD4" ~ "IMD quintile 4",
    term == "IMD5" ~ "IMD quintile 5 (least deprived)",
    term == "GenderWomen" ~ "Gender Women (reference)",
    term == "GenderMen" ~ "Gender Men",
    term == "ethnic_groupWhite British" ~ "ethnic group White British (reference)",
    term == "ethnic_groupWhite Other" ~ "ethnic group White Other",
    term == "ethnic_groupMixed/Multiple" ~ "ethnic group Mixed/Multiple",
    term == "ethnic_groupAsian Other" ~ "ethnic group Asian Other",
    term == "ethnic_groupBlack African" ~ "ethnic group Black African",
    term == "ethnic_groupBlack Caribbean" ~ "ethnic group Black Caribbean",
    term == "ethnic_groupBlack Other" ~ "ethnic group Black Other",
    term == "ethnic_groupIndian, Pakistani or Bangladeshi" ~ "ethnic group Indian, Pakistani or Bangladeshi",
    term == "ethnic_groupOther" ~ "ethnic group Other",
    term == "age_group16 to 24" ~ "age group 16 to 24",
    term == "age_group25 to 34" ~ "age group 25 to 34",
    term == "age_group35 to 49" ~ "age group 35 to 49 (reference)",
    term == "age_group50 to 64" ~ "age group 50 to 64",
    term == "age_group65 to 79" ~ "age group 65 to 79",
    term == "age_group80 and over" ~ "age group 80 and over",
    TRUE ~ term
  ))

# Create forest plot for Non-Automated Sites
forest_plot_non_auto <- ggplot(forest_plot_data_non_auto, aes(x = OR, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = CI_lower, xmax = CI_upper)) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  xlab("Odds Ratio") +
  ylab("Predictor Variables") +
  ggtitle("Forest Plot of HBV Logistic Regression Results (Non-Automated Sites)") +
  theme_pubr() +
  theme(axis.text.y = element_text(hjust = 1, size = 10))

# Save and display the forest plot
ggsave("forest_plot_non_auto_hbv.png", plot = forest_plot_non_auto, width = 10, height = 8)
print(forest_plot_non_auto)


```



```{r Stratified-Nested-analysis-auto-nonauto-all-sites-comparison}

# Load the HIV dataset
df_hbv <- read_csv("hbv_test_uptake_line_list.csv")

# List of automated sites
automated_sites <- c('RJ122', 'RYJ02', 'R0A02', 'R0A66', 'RJ231', 
                     'RJ224', 'RQM91', 'R0A07', 'RYJ01')

# Create a new variable to indicate if a site is automated
df_hbv <- df_hbv %>%
  mutate(is_automated = ifelse(Site %in% automated_sites, "Automated", "Non-automated"))

# Stratify the data
df_automated <- df_hbv %>% filter(is_automated == "Automated")
df_non_automated <- df_hbv %>% filter(is_automated == "Non-automated")

# Fit models within each stratum
model_automated <- glm(HBV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped, 
                       data = df_automated, family = binomial)

model_non_automated <- glm(HBV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped, 
                           data = df_non_automated, family = binomial)

# Fit a model for all sites
model_all_sites <- glm(HBV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped, 
                       data = df_hbv, family = binomial)

# Output model summaries
print("Model Summary for Automated Sites:")
summary(model_automated)

print("\nModel Summary for Non-Automated Sites:")
summary(model_non_automated)

print("\nModel Summary for All Sites:")
summary(model_all_sites)

# Perform 10-fold cross-validation for stratified models
set.seed(123)  # for reproducibility
cv_folds_auto <- createFolds(df_automated$HBV_test, k = 10)
cv_folds_non_auto <- createFolds(df_non_automated$HBV_test, k = 10)
cv_folds_all <- createFolds(df_hbv$HBV_test, k = 10)

cv_results_auto <- lapply(cv_folds_auto, function(test_indices) {
  train_data <- df_automated[-test_indices, ]
  test_data <- df_automated[test_indices, ]
  
  # Train and test model for automated sites
  model_auto_cv <- glm(HBV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped, 
                       data = train_data, family = binomial)
  auto_pred <- predict(model_auto_cv, newdata = test_data, type = "response")
  auto_auc <- auc(test_data$HBV_test, auto_pred)
  
  return(auto_auc)
})

cv_results_non_auto <- lapply(cv_folds_non_auto, function(test_indices) {
  train_data <- df_non_automated[-test_indices, ]
  test_data <- df_non_automated[test_indices, ]
  
  # Train and test model for non-automated sites
  model_non_auto_cv <- glm(HBV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped, 
                           data = train_data, family = binomial)
  non_auto_pred <- predict(model_non_auto_cv, newdata = test_data, type = "response")
  non_auto_auc <- auc(test_data$HBV_test, non_auto_pred)
  
  return(non_auto_auc)
})

cv_results_all <- lapply(cv_folds_all, function(test_indices) {
  train_data <- df_hbv[-test_indices, ]
  test_data <- df_hbv[test_indices, ]
  
  # Train and test model for all sites
  model_all_cv <- glm(HBV_test ~ age_group + Gender + ethnic_group + IMD + attendances_grouped, 
                      data = train_data, family = binomial)
  all_pred <- predict(model_all_cv, newdata = test_data, type = "response")
  all_auc <- auc(test_data$HBV_test, all_pred)
  
  return(all_auc)
})

cv_results_df_auto <- data.frame(AUC_Automated = unlist(cv_results_auto))
cv_results_df_non_auto <- data.frame(AUC_Non_Automated = unlist(cv_results_non_auto))
cv_results_df_all <- data.frame(AUC_All_Sites = unlist(cv_results_all))

print("\nCross-validation Results (AUC) for Automated Sites:")
print(cv_results_df_auto)

print("\nCross-validation Results (AUC) for Non-Automated Sites:")
print(cv_results_df_non_auto)

print("\nCross-validation Results (AUC) for All Sites:")
print(cv_results_df_all)

print("\nMean AUC for Automated Sites:")
print(mean(cv_results_df_auto$AUC_Automated))

print("\nMean AUC for Non-Automated Sites:")
print(mean(cv_results_df_non_auto$AUC_Non_Automated))

print("\nMean AUC for All Sites:")
print(mean(cv_results_df_all$AUC_All_Sites))




```


